<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iOSHub</title>
  
  <subtitle>留一片有趣的天地</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-03T11:56:57.247Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ChanJH</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>源码阅读：JDStatusBarNotification</title>
    <link href="http://yoursite.com/2018/02/03/0015/"/>
    <id>http://yoursite.com/2018/02/03/0015/</id>
    <published>2018-02-03T11:58:00.000Z</published>
    <updated>2018-02-03T11:56:57.247Z</updated>
    
    <content type="html"><![CDATA[<p>JDStatusBarNotification 源码阅读</p><a id="more"></a><h2 id="功能与使用"><a href="#功能与使用" class="headerlink" title="功能与使用"></a>功能与使用</h2><p>JDStatusBarNotification 可以用于在状态栏、应用底部展示一条横幅通知。新版本适配了 iPhone X，支持了显示一条 Process，用法很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[JDStatusBarNotification addStyleNamed:@&quot;failStyleName&quot;</div><div class="line">                               prepare:^JDStatusBarStyle *(JDStatusBarStyle *style) &#123;</div><div class="line">                                   style.textColor = [UIColor whiteColor];</div><div class="line">                                   style.animationType = JDStatusBarAnimationTypeFade;</div><div class="line">                                   style.font = [UIFont fontWithName:@&quot;&quot; size:17.0];</div><div class="line">                                   return style;</div><div class="line">                               &#125;];</div><div class="line">[JDStatusBarNotification showWithStatus:@&quot;请求超时&quot;</div><div class="line">                           dismissAfter:2.0</div><div class="line">                              styleName:@&quot;failStyleName&quot;];</div></pre></td></tr></table></figure><h2 id="代码概况"><a href="#代码概况" class="headerlink" title="代码概况"></a>代码概况</h2><p>JDStatusBarNotification 的类数量很少，只有下列四个</p><ul><li>JDStatusBarNotification</li><li>JDStatusBarStyle</li><li>JDStatusBarView</li><li>JDStatusBarLayoutMarginHelper</li></ul><p>JDStatusBarNotification 是 JDStatusBarNotification 库的使用者接触最多的类，负责操作通知的 show、dismiss。JDStatusBarStyle 负责定义通知的样式。而 JDStatusBarView 是通知的一个 UIView，上面有 textLabel 等。</p><h2 id="JDStatusBarNotification"><a href="#JDStatusBarNotification" class="headerlink" title="JDStatusBarNotification"></a>JDStatusBarNotification</h2><p>JDStatusBarNotification 包含有四个类：</p><ul><li>JDStatusBarStyle (Hidden)</li><li>UIApplication (mainWindow)</li><li>JDStatusBarNotificationViewController</li><li>JDStatusBarNotification</li></ul><p>其中，<code>JDStatusBarStyle (Hidden)</code> 实际上是对 JDStatusBarNotification 暴露 JDStatusBarStyle 隐藏的两个接口，这样就实现了私有 API 的对接。<code>UIApplication (mainWindow)</code> 则是分类。</p><p>JDStatusBarNotification 暴露的接口有三种（都属于自己的方法）：</p><ul><li>show</li><li>dismiss</li><li>setStyle</li></ul><p>这些都是使用 JDStatusBarNotification 的「效果」，但是阅读一个公共库不能只知其然，不知其所以然。因此接下来继续了解一下这些功能是怎么实现的。</p><p>在 JDStatusBarNotification 的 show 方法都是使用类方法。JDStatusBarNotification 使用的是同一个 sharedInstance，可以理解，因为状态栏通知一般都是只显示一条。</p><p>JDStatusBarNotification 的 .m 文件中，interface 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@interface JDStatusBarNotification () &lt;CAAnimationDelegate&gt;</div><div class="line">@property (nonatomic, strong, readonly) UIWindow *overlayWindow;</div><div class="line">@property (nonatomic, strong, readonly) UIView *progressView;</div><div class="line">@property (nonatomic, strong, readonly) JDStatusBarView *topBar;</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSTimer *dismissTimer;</div><div class="line">@property (nonatomic, assign) CGFloat progress;</div><div class="line"></div><div class="line">@property (nonatomic, weak) JDStatusBarStyle *activeStyle;</div><div class="line">@property (nonatomic, strong) JDStatusBarStyle *defaultStyle;</div><div class="line">@property (nonatomic, strong) NSMutableDictionary *userStyles;</div><div class="line">@end</div></pre></td></tr></table></figure><p>UIWindow 是用于显示的所有控件的 superView。 <code>overlayWindow</code> 只设置了他的 windowLevel = UIWindowLevelStatusBar，并没有将它设置为 keyWindow，非 keyWindow 不能接收键盘以及非触摸类的消息。UIWindow有三个层级，分别是Normal，StatusBar，Alert，级别依次增高，级别高的会显示在上面，级别低的在下面。</p><p><code>progressView</code> 和 <code>topBar</code> 都被添加在 <code>self.overlayWindow.rootViewController.view</code> 中。而 rootViewController 其实就是被隐藏的 <code>JDStatusBarNotificationViewController</code> </p><p><code>dismissTimer</code> 用于设置通知自动消失的时间，使用 <code>NSRunLoop</code> 的方法来设置 Timer。需要留意的是，在 <code>- (UIView*)showWithStatus:(NSString *)status style:(JDStatusBarStyle*)style</code> 方法中（所有 show 方法最终都会调用到它）使用了 <code>[[NSRunLoop currentRunLoop] cancelPerformSelector:@selector(dismiss) target:self argument:nil];</code> 来关闭了当前的定时器。</p><p>JDStatusBarNotification 本身会持有一个 userStyles 的字典。key 和 value 分别为 JDStatusStyle 的 name（NSString） 和 Style 对象。默认有以下五种 Style：<code>@[JDStatusBarStyleError, JDStatusBarStyleWarning, JDStatusBarStyleSuccess, JDStatusBarStyleMatrix, JDStatusBarStyleDark, JDStatusBarStyleDefault]</code> 。</p><p><code>self.defaultStyle</code>  在 JDStatusBarNotification 实例化之后是 <code>JDStatusBarStyleDefault</code> 类型。当我们使用 <code>+(NSString*)addStyleNamed:(NSString*)identifier prepare:(JDPrepareStyleBlock)prepareBlock</code> 方法的时候，Notification 会将 defaultStyle 复制一份，然后使用 block 中修改的方法，再保存到 userStyles 字典中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (NSString*)addStyleNamed:(NSString*)identifier</div><div class="line">                   prepare:(JDPrepareStyleBlock)prepareBlock;</div><div class="line">&#123;</div><div class="line">  NSAssert(identifier != nil, @&quot;No identifier provided&quot;);</div><div class="line">  NSAssert(prepareBlock != nil, @&quot;No prepareBlock provided&quot;);</div><div class="line"></div><div class="line">  JDStatusBarStyle *style = [self.defaultStyle copy];</div><div class="line">  [self.userStyles setObject:prepareBlock(style) forKey:identifier];</div><div class="line">  return identifier;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>activeStyle</code> 是指当前 JDStatusBarNotification 正在使用的 Style。当我们使用 <code>+ (UIView*)showWithStatus:(NSString *)status styleName:(NSString*)styleName;</code> 时，就从 <code>userStyles</code> 字典中取出 JDStatusBarStyle 来，保存到 <code>activeStyle</code> 。</p><h2 id="JDStatusBarView"><a href="#JDStatusBarView" class="headerlink" title="JDStatusBarView"></a>JDStatusBarView</h2><p>JDStatusBarView 是 JDStatusBarNotification 内容显示的主要 UIView，包括一个 UILabel 和 UIActivityIndicatorView。</p><h2 id="JDStatusBarStyle"><a href="#JDStatusBarStyle" class="headerlink" title="JDStatusBarStyle"></a>JDStatusBarStyle</h2><p>JDStatusBarStyle 定义了一个 JDStatusBarNotification 的显示效果。属性比较多就不一一列举了。</p><h2 id="JDStatusBarLayoutMarginHelper"><a href="#JDStatusBarLayoutMarginHelper" class="headerlink" title="JDStatusBarLayoutMarginHelper"></a>JDStatusBarLayoutMarginHelper</h2><p>JDStatusBarLayoutMarginHelper 并不是一个类，只是简单的写了一个返回 UIEdgeInsets 的函数（不是方法）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDStatusBarNotification 源码阅读&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS, 开发, 源码阅读" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读：MMPopupView</title>
    <link href="http://yoursite.com/2018/01/28/0014/"/>
    <id>http://yoursite.com/2018/01/28/0014/</id>
    <published>2018-01-28T02:50:00.000Z</published>
    <updated>2018-01-28T03:09:10.955Z</updated>
    
    <content type="html"><![CDATA[<p>MMPopupView 源码阅读</p><a id="more"></a><h2 id="使用-MMPopupView"><a href="#使用-MMPopupView" class="headerlink" title="使用 MMPopupView"></a>使用 MMPopupView</h2><p>我们可以在 Demo 中看到它的使用方法</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0014/F2F3FC95-C8FF-48D9-AD96-69E2CB0B73B2.png" alt=""></p><ul><li>MMAlertView</li><li>MMSheetView</li><li>CustomView</li></ul><p>前面两个是作者提供的两种默认实现，都继承自 <code>MMPopupView</code> 。使用者也可以根据业务需要，制作自己的 CustomView，也是继承 <code>MMPopupView</code> 即可。</p><h2 id="MMPopupView"><a href="#MMPopupView" class="headerlink" title="MMPopupView"></a>MMPopupView</h2><p>这个库的弹窗（MMAlertView、MMSheetView、CustomView）都是继承自 <code>MMPopupView</code> 。它提供的属性有：</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0014/0FF12330-8DB9-4530-867B-61A561C6C88F.png" alt=""></p><p>提供的方法有：</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0014/AEA65404-21E2-4083-B48C-67EB6D8CDB87.png" alt=""></p><p>先从 MMPopupView 的初始化开始看起，可以发现，MMPopupView 的默认实现是 MMAlertView，MMSheetView 其实是在初始化后更改了自己的 type。属性 <code>attachedView</code> 默认是 <code>MMPopupWindow</code> ，这个一会再扩展，先继续阅读 MMPopupView 的方法。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0014/3B7E07AC-3EEC-45FA-8DC6-C8F89E7C5BD0.png" alt=""></p><p>我把 MMPopupView 中的方法分成三类：</p><ul><li>show 相关</li><li>hide 相关</li><li>Animation 相关</li></ul><p>按我们了解的相关方法设计规范，show 和 hide 都有它的最终调用方法。<code>showWithBlock</code> 和 <code>hideWithBlock</code>  。</p><p>Animation 是通过 Block 的方式调用的，这个 block 把 MMPopupView 对象重新传回去，在 block 中操作 self 对象。</p><p>类中提供了六种默认的动画实现。动画是在 <code>hideWithBlock</code> 的 block 完成之后才调用的。</p><h2 id="MMAlertView"><a href="#MMAlertView" class="headerlink" title="MMAlertView"></a>MMAlertView</h2><p>API：</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0014/1F6C1F41-F8FE-4C24-85E8-0D2A64D75582.png" alt=""></p><p>所有方法实际上最终都使用同一个初始化方法：</p><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title</div><div class="line">                       detail:(<span class="built_in">NSString</span> *)detail</div><div class="line">                        items:(<span class="built_in">NSArray</span> *)items</div><div class="line">             inputPlaceholder:(<span class="built_in">NSString</span> *)inputPlaceholder</div><div class="line">                 inputHandler:(MMPopupInputHandler)inputHandler</div></pre></td></tr></table></figure><p>这也符合多个 init 初始方法的设计规范。</p><p>这个类中的方法比较少，主要是：</p><ul><li>初始化（包含 addSubView）</li><li>showKeyboard、hideKeyBoard</li><li>notify</li></ul><p>这里讲一讲 MMAlertView 使用到比较特别的 API：</p><ul><li>UIView<ul><li><code>setContentCompressionResistancePriority forAxis</code></li><li><code>setContentHuggingPriority forAxis</code></li></ul></li></ul><p>关于这两个 API 的扩展阅读：<a href="https://www.jianshu.com/p/e38157d7b828" target="_blank" rel="external">iOS  AutoLayout中的Content Hugging 和 Content Comp… - 简书</a></p><ul><li>Masonry<ul><li><code>MASViewAttribute *lastAttribute = self.mas_top;</code></li></ul></li></ul><p>另外还有另一个接口 MMAlertViewConfig，用来配置 AlerView 一些必要的信息：</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0014/2A47869B-6E7A-40AA-A502-3069E685A8C1.png" alt=""></p><p><code>+ (MMAlertViewConfig *)globalConfig</code> 是一个全局的单例。</p><h2 id="MMSheetView"><a href="#MMSheetView" class="headerlink" title="MMSheetView"></a>MMSheetView</h2><p>和 MMAlertView 相似，有一个 <code>MMSheetViewConfig</code> 。但是提供的初始化 API 只有一个</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0014/9389BF9E-34E2-413F-85BF-C1954FB1CAF8.png" alt=""></p><p>区别是没有 Detail、没法进行 input 以及 confirm 的默认实现（也就是说 MMSheetView 完全按照你输入的 item 进行变化）</p><h2 id="MMPopupWindow"><a href="#MMPopupWindow" class="headerlink" title="MMPopupWindow"></a>MMPopupWindow</h2><p>MMPopupWindow 继承自 UIWindow，UIWindow 又继承自 UIView。当我们创建一个视图，并且希望该视图独立于其他 UI 层的时候，那么我们就可以使用 UIWindow。</p><p>在这个库中，MMPopupWindow 是 MMPopupView 的 super view。从 Reveal 我们可以看到它们的结构关系。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0014/B889BE69-17F5-4D66-B2C5-183159B156DC.png" alt=""></p><p>MMPopupWindow 的方法有以下两类：</p><ul><li>初始化与销毁</li><li>手势操作</li></ul><p>属性 <code>attachView</code> 是 MMPopViewWindow 的根视图。每个 UIWindow 都有一个 <code>rootViewController</code> 属性。</p><h2 id="MMPopupView-的展示过程"><a href="#MMPopupView-的展示过程" class="headerlink" title="MMPopupView 的展示过程"></a>MMPopupView 的展示过程</h2><p>这里主要讲一讲各个 View 是怎么被创建、添加、展示的。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0014/48AD14F7-F7B5-4758-8787-DABD1DC2CF68.png" alt=""><br>MMAlertView UML</p><p>MMAlertView 继承自 MMPopupView，其中的 <code>attachedView</code> 指向 MMPopupWindow 对象。MMPopupWindow 对象将 MMPopupView 添加到自己上面，MMPopupView 负责添加 Item、Title 等。而将 MMPopupWindow 做为 KeyWindow 展示，是在 MMPopupView 中的 <code>showWithBlock</code> 的这句：<code>[self.attachedView mm_showDimBackground]</code>  ，这是使用了 <code>MMPopupCategory</code> 中的一个分类方法，下面讲解一下这个分类。</p><h2 id="MMPopupCategory"><a href="#MMPopupCategory" class="headerlink" title="MMPopupCategory"></a>MMPopupCategory</h2><ul><li>UIColor (MMPopup)</li><li>UIImage (MMPopup)</li><li>UIButton (MMPopup)</li><li>NSString (MMPopup)</li><li>UIView (MMPopup)</li></ul><h3 id="比较简单的几个"><a href="#比较简单的几个" class="headerlink" title="比较简单的几个"></a>比较简单的几个</h3><p>UIColor、UIButton、NSString、UIImage的分类比较简单常见，功能如下：</p><ul><li>UIColor：<code>mm_colorWithHex</code> （使用十六进制 hex 转为 UIColor 对象）</li><li>UIButton：<code>mm_buttonWithTarget:(id)target action:(SEL)sel</code> （添加 Button 的 Action）</li><li>NSString：<code>mm_truncateByCharLength</code> （缩短字符串）</li><li>UIImage：<code>mm_imageWithColor</code> （返回一张充满颜色的 UIImage）</li></ul><h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><p>UIView 大量使用了 <code>objc_getAssociatedObject</code> 和 <code>objc_setAssociatedObject</code> 关联对象的方法。</p><p>简单说，关联对象是通过键给当前的对象绑定另一个对象，当我们需要读取或修改的时候又通过键的方式传递。关联对象一方向可以用来传递一些比较私密的 API，或者在回调的时候（Delegate 或 Block）作为取值的方式减少代码荣冗余，也可以用在为 Category 添加属性（Category 是不能新建 property 的。如果写了，编译器会警告，提示需要手写 set 和 get 方法）。</p><p>这里的 UIView 分类就是运用关联对象给 Category 添加属性的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MMPopupView 源码阅读&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS, 开发, 源码阅读" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>MVVM、面向协议： MoSplash 的新尝试</title>
    <link href="http://yoursite.com/2017/11/21/0013/"/>
    <id>http://yoursite.com/2017/11/21/0013/</id>
    <published>2017-11-21T07:40:00.000Z</published>
    <updated>2017-11-21T07:43:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>MoSplash 最近在做 Code Review 和 Refect，希望让它能够适应更多更大的需求。也是想把最近学习的知识应用上来。写这篇文章的目的，是想把重构的思路记录下来。</p><a id="more"></a><h2 id="MVC-的原罪"><a href="#MVC-的原罪" class="headerlink" title="MVC 的原罪"></a>MVC 的原罪</h2><p>入门 iOS 的同学都会被教育一套 MVC 的架构模型。MVC 是苹果鼓励使用的模型，它由下面三部分组成：</p><ul><li>Model：数据模型，负责模型管理</li><li>Controller：控制器，负责逻辑处理</li><li>View：视图，负责显示和响应</li></ul><p>在 MVC 模型中，Controller 负责把从 Model 传递过来的数据进行逻辑处理，然后告诉 View 显示元素。Controller 也负责处理 View 的响应，处理逻辑后更新数据。</p><p>MVC 模型有一个很大的优点就是容易理解。也有一个人尽皆知的诟病，就是 Controller 的臃肿。MVVM 就是一个为 Controller 瘦身的模型思路。</p><h2 id="了解-MVVM"><a href="#了解-MVVM" class="headerlink" title="了解 MVVM"></a>了解 MVVM</h2><p>在上一篇文章《<a href="http://blog.ioshub.cn/2017/10/30/0012/" target="_blank" rel="external">iOS 中「数据」的流动：从 JSON 到 MVVM</a>》中的最后，我对两种 Model View —— Data Source &amp; Data Controller 的设计进行了简单的分析。Data Source 使用了 Protocol 的设计模式，将数据的逻辑从 View  Controller 分离并作为后者的 Data Source。而 Data Controller 则是封装了 View Controller 的数据逻辑，让后者持有前者，支持操作前者。</p><p>MVVM 在前两年就已经很火，网上对它的赞誉和对它的过誉的思考都有很多文章，这里就不过多累赘。放上几篇参考文章。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0013/bg2015020110.png" alt=""></p><ul><li><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="external">MVC，MVP 和 MVVM 的图示 - 阮一峰的网络日志</a></li><li><a href="http://www.infoq.com/cn/articles/rethinking-mvc-mvvm" target="_blank" rel="external">被误解的MVC和被神化的MVVM</a></li><li><a href="http://gracelancy.com/blog/2016/01/06/ape-ios-arch-design/" target="_blank" rel="external">猿题库 iOS 客户端架构设计 - Lancy’s Blog</a></li><li><a href="https://objccn.io/issue-13-1/" target="_blank" rel="external">ObjC 中国- MVVM 介绍</a></li></ul><h2 id="MVVM-in-MoSplash"><a href="#MVVM-in-MoSplash" class="headerlink" title="MVVM in MoSplash"></a>MVVM in MoSplash</h2><p>我们思考对工程开始一种新的设计模式的时候，一定要理解这种设计模式在里面的应用和作用（积极与消极）。</p><p>MoSplash 在十一月之前采用都是基础的 MVC 和单继承的设计模式。而在应用，需要重复并且大量的展示图片的列表，过去的设计里代码复用性得不到提高，造成大量的重复和垃圾代码。</p><p>其实，我们只需要制造一个通用的 View Controller  让它的子类持有不同的 Data Controller，不同的 Data Controller 持有不同的 API，并为 VC 提供不同的数据源，就能让 View Controller 的代码实现了复用。</p><p>另外，可以用 Protocol 的模式，为每一个 Photo Data Controller 制定一组 Data Protocol，配合 Base Data Controller 的继承，可以加大代码的鲁棒性。Protocol 的设计是后话，我们后面再讲。</p><p>我们假设业务中需要一个 HomeViewController 的控件，它与架构中其他部分的关系如下图：</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0013/MS.png" alt=""></p><p>我们让 HomeViewController 持有了一个 MSPhotoListController。后者负责展示一个图片列表，拥有 ViewController 的逻辑，然而没有数据来源。于是 HomeViewController 为自己的 MSPhotoListController 指定了一个 HomeDataController。通过自定义 DataController 的方法，让列表显示不同内容。这就是上一篇文章中说的，让 VC 拥有 DC 的一种 MVVM 实现方式。</p><p>这里的 MSPhotoListController 就是 MoSplash 中通用的 ViewController，每一个需要使用它的组件，通过为它配制不同的 DC 的方式，让它显示不同的内容。为了让 Data Controller 更好适应业务，我为其设定了继承和协议两种约束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@implementation MSPhotoDataController</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    if(self = [super init])</div><div class="line">    &#123;</div><div class="line">        if([self conformsToProtocol:@protocol(DataControllerProtocol)])</div><div class="line">        &#123;</div><div class="line">// init</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            NSException *exception = [[NSException alloc]initWithName:@&quot;DataControllerProtocol Exception&quot; reason:@&quot;没有遵循DataControllerProtocol协议&quot; userInfo:nil];</div><div class="line">            @throw exception;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@implementation MSPhotoListController</div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    if(![self.dataController.class isKindOfClass:[MSPhotoDataController class]])&#123;</div><div class="line">        // 抛出错误</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure><h2 id="面向协议-in-MoSplash"><a href="#面向协议-in-MoSplash" class="headerlink" title="面向协议 in  MoSplash"></a>面向协议 in  MoSplash</h2><p>在 Data Controller in MoSplash 的设计里，协议和继承都是为了代码尽可能的实现复用，减少代码重复的同时，增加项目的鲁棒性。</p><p>在使用这两种模式实现代码复用之前，我们要先想清楚两者的区别。关于代码的复用，二者都不是万能的。在 MoSplash MVVM 设计中，继承为子类提供了主要方法的默认实现以及基本的数据对象，而 Protocol 的核心作用是让子类提供「配置信息」，从而向父类传递子类想要实现的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@protocol DataControllerProtocol</div><div class="line"></div><div class="line">@required</div><div class="line">/**</div><div class="line"> * 用于查重的 Model 的属性名</div><div class="line"> */</div><div class="line">- (NSString *)sortPropertyName;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Cache saved key</div><div class="line"> */</div><div class="line">- (NSString *)cacheKey;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Get cache</div><div class="line"> */</div><div class="line">- (NSArray *)getCache;</div><div class="line"></div><div class="line">@optional</div><div class="line">/**</div><div class="line"> * 可选方法</div><div class="line"> * 用于缓存数据</div><div class="line"> */</div><div class="line">- (void)saveCache;</div><div class="line">@end</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">/* ----------------------------------------- */</div><div class="line">/**</div><div class="line"> * 数据加载的委托方法</div><div class="line"> */</div><div class="line">@protocol MSPhotoDataControllerDelegate&lt;NSObject&gt;</div><div class="line"></div><div class="line">@optional</div><div class="line"></div><div class="line">- (void)dataLoadWillStar;</div><div class="line">- (void)dataLoadDidFinishedWithError:(NSError *)error;</div><div class="line"></div><div class="line">@required</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/* ----------------------------------------- */</div><div class="line">@interface MSPhotoDataController : NSObject</div><div class="line">/**</div><div class="line"> * 当前数据的 Page Index</div><div class="line"> */</div><div class="line">@property (nonatomic, assign) NSInteger curIndex;</div><div class="line"></div><div class="line">@property (nonatomic, weak) id &lt;MSPhotoDataControllerDelegate&gt; delegate;</div><div class="line"></div><div class="line">@property (nonatomic, weak, readonly) id&lt;DataControllerProtocol&gt; child;</div><div class="line"></div><div class="line">/* ----------------------------------------- */</div><div class="line">/**</div><div class="line"> * 装配完成后的数组，可用于数据显示</div><div class="line"> */</div><div class="line">@property (nonatomic, copy) NSArray *modelArray;</div><div class="line">/**</div><div class="line"> * 数据请求完成后，得到的原始数组</div><div class="line"> */</div><div class="line">@property (nonatomic, copy) NSArray *rawModelArray;</div><div class="line">/**</div><div class="line"> *</div><div class="line"> */</div><div class="line">@property (nonatomic, strong) NSString *searchKeyword;</div><div class="line"></div><div class="line">/* ----------------------------------------- */</div><div class="line">/**</div><div class="line"> * 根据页数加载新的数据</div><div class="line"> * @param index 索引</div><div class="line"> */</div><div class="line">- (void)loadAtIndex:(NSUInteger)index;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 根据页数和搜索关键字加载数据</div><div class="line"> * @param index 索引</div><div class="line"> * @param keyword 搜索关键字</div><div class="line"> */</div><div class="line">- (void)searchAtIndex:(NSUInteger)index</div><div class="line">          withKeyword:(NSString *)keyword;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>由于使用了 MVVM 重构了 MoSplash 项目，让原有几百行的类，减少到每个只有一百行甚至不到，让代码维护成本降低。当然，也带来一些问题，比较代码理解难度上升，这些问题可能可以通过书写文档的方式解决。</p><p>另外，面向协议的思想会加强类的鲁棒性，给予架构设计师一些很好的设计方向。</p><hr><p>更多个人分享，可以瞧瞧我不怎么更新的技术博客：<a href="blog.ioshub.cn">iOSHub</a>。当然还有非技术的 <a href="zhuanlan.zhihu.com/chantalk">ChanTalk</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MoSplash 最近在做 Code Review 和 Refect，希望让它能够适应更多更大的需求。也是想把最近学习的知识应用上来。写这篇文章的目的，是想把重构的思路记录下来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS, 开发, 设计模式" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>iOS 中「数据」的流动：从 JSON 到 MVVM</title>
    <link href="http://yoursite.com/2017/10/30/0012/"/>
    <id>http://yoursite.com/2017/10/30/0012/</id>
    <published>2017-10-30T10:40:00.000Z</published>
    <updated>2017-10-31T01:13:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文希望从『网络请求』这个常见的数据诞生地开始，广度的讲解 iOS 中常见的数据流动的知识。为了保证篇幅，一些入门的知识点不做扩展，每个标题下都有对应知识点，可以自行搜索学习。</p><ul><li>目录：<ul><li>JSON 转字典那点事儿（网络数据解析）</li><li>字典到 Model 发生了什么事儿（OC Runtime）</li><li>Model 的保存这件事儿（iOS 持久层方案）</li><li>数据层的设计探讨 （架构与设计模式）</li></ul></li></ul><a id="more"></a><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0012/QQ20171030-185021@2x.png" alt=""></p><h2 id="0x00-JSON-转字典那点事儿"><a href="#0x00-JSON-转字典那点事儿" class="headerlink" title="0x00 JSON 转字典那点事儿"></a>0x00 JSON 转字典那点事儿</h2><ul><li>知识点：网络请求、HTTP 协议、NSJSONSerialization 使用</li></ul><p>先看一下这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSURL *url = [NSURL URLWithString:@&quot;&quot;];</div><div class="line"></div><div class="line">NSURLSession *session = [NSURLSession sharedSession];</div><div class="line">NSURLSessionTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class="line"></div><div class="line">    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];</div><div class="line">    NSLog(@&quot;%@&quot;, dic);</div><div class="line">    </div><div class="line">&#125;];</div><div class="line"></div><div class="line">[task resume];</div></pre></td></tr></table></figure><p>这是一段简单的 NSURLSession 网络请求的 OC 代码。这里的关注点在 completionHandler 的 block 里。Handler 里返回了两个关键的参数：data 和 response。这里就需要一些 HTTP 协议的知识。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0012/QQ20171030-184732@2x.png" alt=""></p><p>一个 HTTP 请求其实包含了请求头和请求题。在这里，上面是 Head（响应头），下面是 Body（响应体），分别对应 Block 里的 Response 和 Data。</p><p>在 block 里，response 表示为一个 NSURLResponse 对象，通过打印就能清楚看明白它的结构。而 Data 是一个 NSData 对象，应该怎么理解呢？</p><p>这里要用 HTTP 在 TCP/IP 中传输的知识了。</p><p>简单讲就是在计算机网络里，数据被二进制化（序列化）、分包等操作后，在网络里传输。这个 data 就是一个序列化的结果（可以通过断点看到）。而我们怎么利用这个结果呢？</p><p>如果是 JSON，那么使用 NSJSONSerialization 的 JSONObjectWithData 方法可以得到 OC 对象（id 对象），此时根据 JSON 格式的不同，可以解析为 dictionary 或者 array。除了 NSJSONSerialization，也有其他的第三方库可以使用，它们可以处理更多 JSON 可能出现的情况。</p><p>对于 XML 可以用 NSXMLParser 解析。如果是其他数据（比如图片）可以用他们对应的构造器实现。</p><h2 id="0x01-字典到-Model-发生了什么事儿"><a href="#0x01-字典到-Model-发生了什么事儿" class="headerlink" title="0x01 字典到 Model 发生了什么事儿"></a>0x01 字典到 Model 发生了什么事儿</h2><ul><li>知识点：Model 层的封装、Runtime</li></ul><h3 id="常规的字典转-Model"><a href="#常规的字典转-Model" class="headerlink" title="常规的字典转 Model"></a>常规的字典转 Model</h3><p>其实这个过程就是常说的「字典转对象」的过程。这个过程其实不难，入门的话也很容易理解，但是要做到能够把代码写得足够优雅，就要了解多一些知识才行了。我们先来看一下，入门级别的「字典转对象」是怎么做的。定义一个 Model 有下列 property：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface PhotoModel</div><div class="line">@property (nonatomic, copy) NSString *link;</div><div class="line">@end</div></pre></td></tr></table></figure><p>这是一个 PhotoModel，有一个对应链接的属性。当我们从网络获得 data，解析为字典之后，想要转为 Model 时，可以在 PhotoModel 里定义 <code>initWithDic</code> 方法，就能在实现里转化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(instancetype)initWithDic:(NSDictionary *)dic&#123;</div><div class="line">    self = [super init];</div><div class="line">    if(self)&#123;</div><div class="line">        _link = dic[@&quot;link&quot;];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>嗯，这样就完成了 JSON 转 Model 的过程。</p><p>这种方法本身没毛病，只是代码十分简陋。想象一下，当我们的模型拥有大量的属性时候，是不是需要复制粘贴大量的属性和键值对？可能维护一个 <code>init</code> 方法而已不足以带来麻烦，那如果你的 model 需要 Archive 呢？</p><p>我们知道，在 iOS Foundation 里支持一种数据保存方式叫 Archive（中文可以翻译为归档）。需要 Archive 的 Model 需要遵循 <code>NSCoding</code> 并实现 <code>-(void)encodeWithCoder:(NSCoder *)aCoder</code> 和 <code>-(id)initWithCoder:(NSCoder *)aDecoder</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">-(void)encodeWithCoder:(NSCoder *)aCoder&#123;</div><div class="line">    [aCoder encodeObject:self.link forKey:@&quot;link&quot;];</div><div class="line">&#125;</div><div class="line">-(id)initWithCoder:(NSCoder *)aDecoder&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        self.link = [aDecoder decodeObjectForKey:@&quot;link&quot;];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">这样你知道麻烦在哪了吧：你将维护之前三倍的代码！所以，字典转 Model 需要更科学的方法。</div><div class="line"></div><div class="line">### OC 的 Runtime 特性</div><div class="line"></div><div class="line">Objective-C 是一门动态绑定的语言。这句话相信我们在入门 iOS 的时候就已经听说，但是并不能理解它的含义。</div><div class="line"></div><div class="line">我们熟悉的 C 语言使用的「静态绑定」，也就是说，在编译期就能决定运行时所应调用的函数。</div><div class="line"></div><div class="line">``` C</div><div class="line">void funcA()&#123;</div><div class="line">&#125;</div><div class="line">void funcB()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void funcMain(int type)&#123;</div><div class="line">if(type == 0)&#123;</div><div class="line">funcA()</div><div class="line">&#125;</div><div class="line">else&#123;</div><div class="line">funcB()</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果换成这个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcMain</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</div><div class="line"><span class="keyword">void</span> (*func)();</div><div class="line"><span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</div><div class="line">func = funcA;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">func = funcB;</div><div class="line">&#125;</div><div class="line">func();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>那就需要用到动态绑定了。而 OC 就是一门动态语言，所要调用的函数直到运行期才确定。依靠强大的 Runtime 来实现这个功能。</p><p>利用 OC 的动态绑定的特性，我们可以在运行时观察 Model 的属性，甚至做到属性值的修改。下面以 Model 的封装来举例说明这个特性。同时，为了简单理解，只使用了继承的模式来实现 Model 封装。</p><p>我们的思路是，在程序运行时，使用代码枚举出 model 的属性，将属性名转化为 NSString 变量，那样就可以和字典的键（Key）对应上去了！思路是不是很简单。</p><p>首先需要引入 OC 的 runtime 框架 <code>#import &lt;objc/runtime.h&gt;</code> 。接着需要获取类的 Property，这里要用 <code>class_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount)</code> 的函数，它返回的是一个经过封装的 <code>objc_property_t</code> 指针，我们先认为它是一个类数组吧。</p><p>然后我们开始遍历数组，对每个 property  使用 <code>property_getName()</code> 函数获取它的属性名，这是一个 <code>const char</code> 类型的变量，只要用 UTF8 编码后，就是一个 NSString 对象了！</p><p>如果使用 KVC 的特性，可以对 model 使用 <code>[self setValue:[aDecoder decodeObjectForKey:nameStr] forKey:nameStr];</code> 设定属性的值。</p><p>对应的 <code>- (instancetype)initWithCoder:(NSCoder *)aDecoder</code> 和 <code>- (void)encodeWithCoder:(NSCoder *)aCoder</code> 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#import &quot;JHBaseModel.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@implementation JHBaseModel</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123;</div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    unsigned int propertyCount = 0;</div><div class="line">    objc_property_t * properties = class_copyPropertyList([self class], &amp;propertyCount);</div><div class="line">    </div><div class="line">    for (unsigned int i = 0; i &lt; propertyCount; ++i) &#123;</div><div class="line">        objc_property_t property = properties[i];</div><div class="line">        const char * name = property_getName(property);</div><div class="line">        </div><div class="line">        NSString *nameStr = [NSString stringWithUTF8String:name];</div><div class="line">        [self setValue:[aDecoder decodeObjectForKey:nameStr] forKey:nameStr];</div><div class="line">    &#125;</div><div class="line">    if (properties)&#123;</div><div class="line">        free(properties);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder&#123;</div><div class="line">    </div><div class="line">    unsigned int propertyCount = 0;</div><div class="line">    objc_property_t * properties = class_copyPropertyList([self class], &amp;propertyCount);</div><div class="line">    </div><div class="line">    for (unsigned int i = 0; i &lt; propertyCount; ++i) &#123;</div><div class="line">        objc_property_t property = properties[i];</div><div class="line">        const char * name = property_getName(property);</div><div class="line">        </div><div class="line">        NSString *nameStr = [NSString stringWithUTF8String:name];</div><div class="line">        [aCoder encodeObject:[self valueForKey:nameStr] forKey:nameStr];</div><div class="line">    &#125;</div><div class="line">    if (properties)&#123;</div><div class="line">        free(properties);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样，我们只要将 Model 继承于 JHBaseModel，就能不必再一次次地去实现两个 <code>NSCoding</code> 协议里的方法了。</p><p>那有朋友问，还是没解决 <code>-(instancetype)initWithDic:(NSDictionary *)dic</code> 的方法嘛。其实如果你的服务器返回的 JSON 字段是和 Model 属性名对应的，那用上面 <code>- (instancetype)initWithCoder:(NSCoder *)aDecoder</code> 的变形就能完成需求。</p><p>不过，有时候 JSON 的字段并不符合 OC 的命名习惯甚至直接不能那么命名（比如 id 字段），我们就必须手动维护一张字段解析的表。这类的做法比如著名的库：Mantle </p><h3 id="常见的字典转-Model-方法"><a href="#常见的字典转-Model-方法" class="headerlink" title="常见的字典转 Model 方法"></a>常见的字典转 Model 方法</h3><ul><li>Mantle：使用继承和协议的方法</li><li>MJExtension：使用类扩展的方法</li><li>自己封装 BaseModel 类，使用 Protocol 和继承的方法，实现字典转 Model</li></ul><h2 id="0x02-Model-的保存这件事儿"><a href="#0x02-Model-的保存这件事儿" class="headerlink" title="0x02 Model 的保存这件事儿"></a>0x02 Model 的保存这件事儿</h2><ul><li>知识点：iOS 的数据持久化</li></ul><p>到目前为止，我们的数据都只是以各个 OC 的『对象』形式存在于内存中。我们的应用需要把数据保存到硬盘里，来应付多种场景。常见的缓存保存方式：</p><ul><li>数据库：大量数据。主要用于商品列表、聊天记录之类</li><li>文件：图片、音频、视频</li><li>内存：使用频率非常高的数据</li></ul><p>在 iOS 里，保存方法可以有：</p><ul><li>Archive</li></ul><p>对于需要归档的对象，需要遵循 NSCoding 协议，实现 <code>encodingWithCoder:(NSCoder *)aCoder</code> 和 <code>initWithCoder:(NSCoder *)aDecoder</code> 方法</p><p>归档时，使用 NSKeyedArchiver  保存数据。取出数据时，用 NSKeyedUnarchiver</p><p>这种方法，把数据归档保存到了硬盘中（可以在路径里找到 .archive 文件）。</p><p>我们的框架 PINCache 也用了 Archive 的方式缓存数据，只不过他的接口更友好。</p><ul><li>SQLite</li></ul><p>SQLite 是移动端的轻量级数据库解决方案，它可以同时在多平台上运行。接下来我们要讲到的 CoreData 和 FMDB，都是基于 SQLite。</p><ul><li>Core Data</li></ul><p>Archive 只能重写整个文件。Core Data 可以只读取已存对象中的一小部分。当模型对象的数量较少时，使用 Archive。而 Core Data 的增量存取、增量更新数据机制，可以胜任大量数据处理。</p><p>Core Data 可以将 OC 对象转化成数据，并将这些数据保存到 SQLite 数据库文件中。但是 Core Data 只能保存有限的几种数据类型（不能保存 UIImage 对象）。</p><p>Core Data 的实际上是 SQLite 的一个面向对象封装。</p><ul><li>FMDB</li></ul><p>FMDB 的封装更靠近关系型存储。更多的保留了数据库本身的特性。</p><ul><li>第三方库：Realm</li></ul><p>Realm 是一个跨平台的数据库，它的 API 设计比 Core Data 优雅，也更加易懂。</p><p>网上有很多关于 Realm、FMDB、Core Data 的讨论，孰优孰劣还要听君定夺。</p><ul><li>其他：WCDB、FireBase</li></ul><h2 id="0x03-数据层的设计探讨"><a href="#0x03-数据层的设计探讨" class="headerlink" title="0x03 数据层的设计探讨"></a>0x03 数据层的设计探讨</h2><ul><li>知识点：架构与设计模式</li></ul><p>当我们了解完整个数据从请求到对象化的过程之后，数据就成一种 OC 对象可以让开发者十分方便地进行处理了。</p><p>我们都知道 MVC 其实讨论的就是数据的流动方向。而 MVC 容易造成 Controller 的臃肿，所以有像 MVVM 这样的模式来减轻 Controller 的负担。接下来以 MVVM 为模型，讨论其中的 ViewModel 在 iOS 中的实现方式。MVVM 基础理论请自行查找相关知识。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0012/mvvm.png" alt=""></p><h3 id="从-UIKit-寻找数据层的设计"><a href="#从-UIKit-寻找数据层的设计" class="headerlink" title="从 UIKit 寻找数据层的设计"></a>从 UIKit 寻找数据层的设计</h3><p>我们可以从 UIKit 里找到苹果在为 ViewCotroller 配置它的数据时的思路。</p><ul><li>DataSource</li></ul><p>UITableView 是我们十分熟悉的一个控件了。使用  TableView 时有 Delegate 和 DataSource 两个重要协议需要我们理解。两种协议都可以认为是一种传值的方法。不同的是，Delegate 是将值从 TableView 传到类，而 DataSource 是从类传到 TableView。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0012/%E6%96%B0%E6%96%87%E6%A1%A3%202017-10-10%2020.15.51_1.jpg" alt=""></p><p>这是一种为 ViewController 瘦身的思路。将 ViewController 的 DataSource 设置为我们的 ViewModel，用它来进行数据的装配。</p><ul><li>UISearchController</li></ul><p>老实说，UISearchController 是我以前经常不理解的一个类，因为它的调用有点奇怪，不像 TableVIew 这样让一个 ViewController 拥有一个 View，而是让 VC 又拥有了一个新的 Controller，那要怎么理解？</p><p>其实我们可以把像 UISearchController 的控制器，称为 DataController。它是从 VC 里抽离出来的关于数据的逻辑处理，以实现 VC 瘦身。让 VC 拥有 DataController 的实例，通过属性读取获得 DataController 的数据、通过方法让 DataController 进行更新。DC 的生命周期保持与 VC 相同。</p><p>DataController 是用 own（拥有）的方式将 VC 和 VM 耦合，DataSource 是用 Protocol（协议）的方式将它们耦合在一起。</p><ul><li>适应性</li></ul><p>在业务开发里，我们可能面对这样的设计需求：一种界面对应多种数据、一种数据对应多种界面。具体来说，在我的独立作品 MoSplash 里，同样是展示图片，数据源可能是首页、可能是精选、可能是收藏，这是一对多；另一个情况发生在我们工作室的项目里，同样的通讯录，在聊天里我们希望直接以『老师』分组展示，而另一个界面希望以『数学组』这样的分组展示。</p><p>上面提到的 ViewModel 设计模式是不是一定需要对应于后文提到的某种情况？答案显然不是。DataSource 和 DataController 的设计都可以应用进两个情况里。</p><p>那会不会会有优劣之分？我个人认为有。但是并不能简单的根据一对多或者多对一就说应该用什么设计。还应该根据业务的复杂度，选择相应设计。上文的例子只是证明，ViewModel 在瘦身和代码复用上的优势。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是 iOS 里，一个数据从网络请求结果到缓存，再到业务内的整个过程。希望对入门的同学使用数据层有一个宏观的了解，也希望为使用 MVVM 模型提供一些思路。</p><hr><p>更多个人分享，可以瞧瞧我不怎么更新的技术博客：<a href="blog.ioshub.cn">iOSHub</a>。当然还有非技术的 <a href="zhuanlan.zhihu.com/chantalk">ChanTalk</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文希望从『网络请求』这个常见的数据诞生地开始，广度的讲解 iOS 中常见的数据流动的知识。为了保证篇幅，一些入门的知识点不做扩展，每个标题下都有对应知识点，可以自行搜索学习。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目录：&lt;ul&gt;
&lt;li&gt;JSON 转字典那点事儿（网络数据解析）&lt;/li&gt;
&lt;li&gt;字典到 Model 发生了什么事儿（OC Runtime）&lt;/li&gt;
&lt;li&gt;Model 的保存这件事儿（iOS 持久层方案）&lt;/li&gt;
&lt;li&gt;数据层的设计探讨 （架构与设计模式）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS, 开发, 基础" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>为多平台（iOS、macOS、watchOS、tvOS）创建通用的 Swift Framework</title>
    <link href="http://yoursite.com/2017/10/14/0011/"/>
    <id>http://yoursite.com/2017/10/14/0011/</id>
    <published>2017-10-14T06:57:00.000Z</published>
    <updated>2017-10-14T07:12:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<a href="https://medium.com/@ataibarkai/create-a-universal-swift-framework-for-ios-os-x-watchos-and-tvos-2aa26a8190dc" target="_blank" rel="external">Create a Universal Swift Framework for iOS, OS X, watchOS, and tvOS</a>  </p><p>译者按：其实 macOS 和 iOS 除了使用的编程语言一样之外，也拥有着不少通用的框架、公共库，在开发双平台应用的时候，model 和很多逻辑可以通用，这样就产生了代码共用的需要。最近我在做一个应用同时拥有 macOS 和 iOS 两个客户端，在 Medium 里找到这篇文章觉得不错，因此翻译了一下。  </p></blockquote><a id="more"></a><p>Xcode 7.2 内提供了为任何平台（iOS, OS X, watchOS, tvOS）创建 Swift Framework 的支持。</p><p>然而，Xcode 并没有提供创建同时支持多平台的、通用的 framework 的功能。</p><p>通用库（Universal framework）是发布开放库的一种最佳的方式。事实上，多亏了包管理工具 Carthage，开发者想发布一款多平台的库只需要保证它可以编译即可。满足这个需要的库只要求开发者在 Carthage 里配置对应的 Git URL 即可。</p><p>然而，这样的操作方法还是缺乏愉悦感。Apple 似乎有意用 <a href="https://github.com/apple/swift-package-manager" target="_blank" rel="external">Swift Package Manager</a>  来取代这样单调的过程，不过还处在 Beta 版的它还是有很长的路要走。下文将一步步地介绍如何创建一个通用的 framework.  这里边有我自己的探索，也有一部分引用了他人的做法。你将不用几分钟的时间就能完成今天的教程。</p><p>Let’s go.</p><h2 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h2><p>从模版中建立新的 Xcode 项目，并选择：</p><p>iOS -&gt; Framework &amp; Library -&gt; Cocoa Touch Framework</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/1F0FB8A8-4821-43F6-923A-23E903BF0DB0.png" alt=""></p><h2 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h2><p>为你的项目起个名字并在名字后面加入「_iOS」。需要留意已经为「Include Unit Tests box」 打了勾勾。</p><p>NOTE：<strong>不要</strong>在你的项目名里包含「-」，因为会产生一个一样的名字的 target，而破折号是一个非法的命名。</p><p>你不必担心，我们将在后面对项目名称进行修改，甚至你可以回来添加破折号（虽然 iOS target 名字还是保持不变）。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/6444BCF9-3D08-4358-AC44-9F045BB1544E.png" alt=""></p><h2 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h2><p>在 Xcode 顶部菜单里，选择 File -&gt; New -&gt; Target</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/E41ACF0C-A05E-4BF9-A7E7-999E351A03A2.png" alt=""></p><h2 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h2><p>选择你想支持的平台的 framework 模版。比如我们选择了 macOS：</p><p>OS X -&gt; Framework &amp; Library -&gt; Cocoa Framework</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/77A7DAF6-8016-49F3-9CAD-B51E2BCEDB72.png" alt=""></p><h2 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h2><p>然后，我们要像前面一样为项目命名，在项目名的最后加上「_Mac」：</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/7CACAB58-F55A-4663-BD91-5C3EDA7FEFCA.png" alt=""></p><h2 id="Step-6"><a href="#Step-6" class="headerlink" title="Step 6"></a>Step 6</h2><p>重复 Step 4 和 5 来添加每个你想要支持的平台</p><h2 id="Step-7"><a href="#Step-7" class="headerlink" title="Step 7"></a>Step 7</h2><p><strong>现在我们将开始重构项目的框架：</strong></p><p>1、删除「_Mac」文件夹，选择「Move to Trash」</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/A17BA90C-AA9F-42A1-85FE-1F95BB4D5BEF.png" alt=""></p><p>2、打开 Finder，进入项目文件夹，删除「_Mac」文件夹（译者注：在 Xcode 9 里，如果你已经选择删除文件时同时丢入垃圾桶，此时这两个文件夹已经不存在）</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/58981ADE-9243-438D-B2A6-6C44589A1AB7.png" alt=""></p><p>3、在当前的文件夹中把「ProjectName_iOS」重命名为「CommonSource」，把「ProjectName_iOSTests」重命名为「CommonTests」</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/88B937DA-12C7-47AD-975D-F94EA97FF177.png" alt=""></p><p>4、回到 Xcode 中，删除那些空的文件夹</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/C7935EDE-EBCC-4DD4-8183-3641073A6208.png" alt=""></p><p>5、先把 <strong>CommonSource</strong> 这个文件夹拉入到项目中（译者注：不需要拉 test 文件夹），<strong>不要选择任何的 「Add to target」</strong></p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/B4CB4D62-1EEC-41F2-BAD1-ABB31BDFF61B.png" alt=""></p><p>6、现在可以重命名项目，删掉「_iOS」后缀，改成你想要的名字。当然你可以保留这样的命名方式。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/D6F52E0C-F351-40E7-9DFE-247DF5615541.png" alt=""></p><p>确定后会提醒是否重命名项目内容，选择「Don’t Rename」</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/D0F2B2ED-3111-43A6-AF5E-3F9F7EE6D231.png" alt=""></p><p>7、为「ProjectName_iOS.h」删除其后缀名</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/14753873-E4C3-4347-B5DE-482EC62F6A51.png" alt=""></p><p>8、现在把  CommonTests 文件夹拉到项目中。同样的，<strong>不要选择任何的「Add to target」</strong></p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/69D85B0B-C794-4E84-8CAE-D12B25E65C1E.png" alt=""></p><p>9、关闭 Xcode 项目，为项目的文件夹名删掉「_iOS」后缀。此时你的文件夹应该长这样：</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/86A45F47-862A-45F9-B913-7401B52220A3.png" alt=""></p><h2 id="Step-8"><a href="#Step-8" class="headerlink" title="Step 8"></a>Step 8</h2><p>到目前为止，我们已经重构完成项目结构。</p><p>接下来我们需要修复一下两个文件的 target memberships。再次打开 Xcode。</p><p>1、选择  CommonSource -&gt; ProjectName.h 文件，然后在右手边的配置中，选择未被标记的 target memberships，并标记为 Public。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/D1332C8A-0650-4AAE-862E-7E9EECCB9C46.png" alt=""></p><p>2、选择 CommonTests -&gt; SwiftyGmail_iOSTests.swift  文件，同样标记。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/797D3E1C-DFA9-478B-AFFA-2163CCEA86DE.png" alt=""></p><p>此时该文件会报错误，你需要重命名引用的库，删掉后缀「_iOS」</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/BC235013-81AB-4648-BAF3-A3370BBA4AAA.png" alt=""></p><p>Before</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/315D6091-FDBE-4B9F-BFCB-E0CF3ED436B3.png" alt=""></p><p>After</p><h2 id="Step-9"><a href="#Step-9" class="headerlink" title="Step 9"></a>Step 9</h2><p>在 Build Setting 中同时选择两个 target，找到 Packaging -&gt; Info.plist file 然后把其中改为 CommonSource/Info.plist</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/BDDD0405-7C70-4DF2-9D9F-CA220658EF4F.png" alt=""></p><h2 id="Step-10"><a href="#Step-10" class="headerlink" title="Step 10"></a>Step 10</h2><p>在 Build Setting 中同时选择两个 target，找到 Packaging -&gt; Product Name 然后把其中改为你的项目名（没有后缀的）</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/17B96CF0-4D5F-4A38-A725-E993D103FC33.png" alt=""></p><h2 id="（可选）Step-11-支持-Carthage"><a href="#（可选）Step-11-支持-Carthage" class="headerlink" title="（可选）Step 11: 支持 Carthage"></a>（可选）Step 11: 支持 Carthage</h2><p>如果你想为你的框架支持 Carthage，你需要修改你的 Schemes 为 Shared</p><p>1、在 Xcode 窗口的左上角点击当前的 Scheme，再点击 Manage Schemes</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/33906722-3EC8-4BF4-8108-384D170F6748.png" alt=""></p><p>2、现在为每个 scheme 标记为 Shared</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0011/2DE6A31F-9276-4646-929A-260BB60129EA.png" alt=""></p><h2 id="Step-12：把该死的源代码拉进来吧！"><a href="#Step-12：把该死的源代码拉进来吧！" class="headerlink" title="Step 12：把该死的源代码拉进来吧！"></a>Step 12：把该死的源代码拉进来吧！</h2><p>OK，你已经完成了本文的内容！</p><p>你可以编译、测试你的库是否支持你想要的平台</p><p>当你添加新的源码时，确保它拉到每个你想要的平台中。单元测试的代码也是一样道理。</p><blockquote><p>以上本文译完。  </p><p>以下为本人在使用过程的踩坑总结，做一个补充。  </p></blockquote><p>1、Xcode 9 的臭虫</p><p>当你使用 9A235 版本的 Xcode 9 时，把文件拉到项目里，就算勾选了 Add to taeget 文件还是没有正确添加进去，此时你要在文件 -&gt; 项目右侧手动添加。</p><p>2、创建 Swift 的 framework 时，公共方法必须标记为 public。详情可以查看这篇文章：<a href="https://www.raywenderlich.com/126365/ios-frameworks-tutorial" target="_blank" rel="external">Creating and Distributing iOS Frameworks</a></p><p>3、经常需要判断对应平台来引用正确的框架，比如 Cocoa for macOS 之于 UIKit for iOS。除了引用，一些逻辑可能也要进行判断。Swift 和 OC 有不一样的代码，下面是实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">OC:</div><div class="line">#if TARGET_OS_IPHONE</div><div class="line">    #import &lt;UIKit/UIKit.h&gt;</div><div class="line">#elif TARGET_OS_MAC</div><div class="line">    #import &lt;Cocoa/Cocoa.h&gt;</div><div class="line">#endif</div><div class="line"></div><div class="line">Swift:</div><div class="line">#if os(iOS)</div><div class="line">    import UIKit</div><div class="line">#elseif os(OSX)</div><div class="line">    import Cocoa</div><div class="line">#endif</div></pre></td></tr></table></figure><p>4、Core Data 的 model 无法在 framework 里共用，会出现无法加载 model 的错误。我目前做法是 model 还是分别放在主项目里。（如果你有更好的解决方法麻烦告诉我，谢～）</p><hr><p>更多个人分享，可以瞧瞧我不怎么更新的技术博客：<a href="blog.ioshub.cn">iOSHub</a>。当然还有非技术的 <a href="zhuanlan.zhihu.com/chantalk">ChanTalk</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://medium.com/@ataibarkai/create-a-universal-swift-framework-for-ios-os-x-watchos-and-tvos-2aa26a8190dc&quot;&gt;Create a Universal Swift Framework for iOS, OS X, watchOS, and tvOS&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;译者按：其实 macOS 和 iOS 除了使用的编程语言一样之外，也拥有着不少通用的框架、公共库，在开发双平台应用的时候，model 和很多逻辑可以通用，这样就产生了代码共用的需要。最近我在做一个应用同时拥有 macOS 和 iOS 两个客户端，在 Medium 里找到这篇文章觉得不错，因此翻译了一下。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS, 开发, macOS, Swift, Framework" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91-macOS-Swift-Framework/"/>
    
  </entry>
  
  <entry>
    <title>适配 iPhone X 之异形屏</title>
    <link href="http://yoursite.com/2017/09/18/0010/"/>
    <id>http://yoursite.com/2017/09/18/0010/</id>
    <published>2017-09-18T08:30:00.000Z</published>
    <updated>2017-09-26T09:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>苹果终于在一年一度的秋季发布会发布了 iPhone 十周年纪念版：iPhone X。</p><p>iPhone X 是 2014 发布 iPhone 6 之后又一次外形的变化，也是 iPhone 历史上（可能）最大的一次外观变化。</p><p>我相信很多开发者和设计师看到 iPhone X  的这个「天猫内定」屏幕的时候心里十分苦恼：该怎么为这个机型做设计和适配？这篇文章从苹果的 iPhone X 开发和设计指南出发，试图来解决这个问题。</p><p>需要注意的是，本文不对设计指南完整的、不保留的搬运，而是根据指南和个人实操，做出的结论。完整的内容请自行查看文末链接。如有错误欢迎指出。</p><a id="more"></a><h2 id="先抛数据"><a href="#先抛数据" class="headerlink" title="先抛数据"></a>先抛数据</h2><p>iPhone X 采用了 2436*1125 分辨率，拥有一块大约 2.17:1 的屏幕。iPhone X 的屏幕像素比 iPhone 8 高出 145 pt。适配 iPhone X 时并不需要像传闻的一样使用 @4x 的素材，而是继续使用 @3x 即可。苹果鼓励我们使用 PDF 素材来缩小包大小。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/7AE29F47-5400-4757-81FC-557C87CCE8B3.png" alt=""><br><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/3D8B841A-9669-4C0F-B416-AB42545B4711.png" alt=""></p><p>iPhone X 的状态栏高度为 44 pt ，iPhone 8 和 iPhone 8 Plus 和以前一样为 20 点。经过我的测试，X 的 tabbar 比以前高出 43 个点（以前是 40，现在是 83）（PS：此处更正：以前 tabbar 为 49 pt，故高出了 34 pt）。需要注意的是，横屏时底部高度为 33 pt。这个数据可以用于底部适配，下文会讨论这个话题。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/610F6838-0524-4D10-BF5C-177F6FD94A14.png" alt=""></p><h2 id="Safe-Area"><a href="#Safe-Area" class="headerlink" title="Safe Area"></a>Safe Area</h2><p>iOS 11  为屏幕适配引入了一个十分重要的概念：Safe Area.</p><p>顾名思义，Safe Area 指的是<strong>屏幕内适合放置控件的安全区域</strong>。概念太模糊，下面举例说明：</p><p>在没有状态栏和其他东西的 iPhone 8 里，Safe Area 是指整个屏幕。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/F385BD6A-F53D-4CB7-B13C-215ABA9BB9F4.png" alt=""></p><p>当加入状态栏后，Safe Area 便向下减少了 20 个点。当我们加入 Navigation 的时候，Safe Area 又减少了 44 个点。同理，我们再加入 Tabbar 的时候，Safe Area 又减少了 44 个点（PS：此处更正， Tabbar 高度应该是 49 pt）。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/safe.jpg" alt=""></p><p>在 iPhone X 里，当我们没有使用状态栏时，Safe Area 依然和上下边有一定的距离。按照我的测量，此时距离底部应该是 43 个点，距离顶部应该是 44 个点。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/85872278-814A-4CD6-AF8B-FCE925DD4020.png" alt=""></p><p>同理，加入不同 Bar 之后，iPhone X 的 Safe Area 都会有相应的变化。</p><p>横屏时， iPhone X 的 Safe Area 与左右和下部都有距离。需要注意的时，像 TableView 这样的控件，需要将它的 Cell ContentView 与 Safe Area  对齐，而把 TableView 内容扩展到整个手机。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/safea.png" alt=""></p><p>因此，Auto layout 在 iPhone X 可以有很好的继承。</p><h2 id="使用-Safe-Area"><a href="#使用-Safe-Area" class="headerlink" title="使用 Safe Area"></a>使用 Safe Area</h2><p>在 xib 里使用 Safe Area 很简单，打开开关就可以了。然后就可以约定控件与 Safe Area 的约束来完成适配。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/saf.png" alt=""></p><p>而在代码里使用 Safe Area，可以使用 view 的 safeAreaLayoutGuide 属性。我找到的一段参考代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if #available(iOS 11, *) &#123;</div><div class="line">  let guide = view.safeAreaLayoutGuide</div><div class="line">  NSLayoutConstraint.activate([</div><div class="line">   greenView.topAnchor.constraintEqualToSystemSpacingBelow(guide.topAnchor, multiplier: 1.0),</div><div class="line">   guide.bottomAnchor.constraintEqualToSystemSpacingBelow(greenView.bottomAnchor, multiplier: 1.0)</div><div class="line">   ])</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="顶部设计误区"><a href="#顶部设计误区" class="headerlink" title="顶部设计误区"></a>顶部设计误区</h2><p>先讲讲最基本的原则：不要因为 iPhone X 的圆角、「刘海」、底部 Home Button 的影响，把控件挡住，影响用户使用。</p><p>如果你的应用使用 Auto Layout，在很大程度上适配起来是没有压力的。</p><p>有些朋友在发布会以后苦恼于 iPhone X 奇葩的双耳朵设计，联想到 X 使用了 OLED 屏幕（黑色像素不发光），想到了把应用顶部做平，置于耳朵之下的设计方案。也有开发者为此造了轮子。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/app.png" alt=""></p><p>然而，根据苹果的设计指南，这类设计是不被允许的。你的应用应该尽可能地充满整个屏幕，不能上下留边。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/032AEC08-EFD6-4FE2-A670-CEAC4171D940.png" alt=""></p><h2 id="底部设计探讨"><a href="#底部设计探讨" class="headerlink" title="底部设计探讨"></a>底部设计探讨</h2><p>昨天我在朋友圈和微博发了这样的两幅图，并询问大家哪个好。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/cancle.png" alt=""></p><p>看了大家的反馈，两种喜欢的人数基本一样（只相差一票）。这是我在给一个 SheetView 做 iPhone X 时候遇到的疑问。带着疑问我把设计指南的视频又重新看了一遍。</p><p>先说结论，这里应该是第二种设计是被苹果鼓励的。下面从设计指南中找答案。</p><p>设计指南对底部适配有两种说法。一是不要将控件放置在易被误触的 Home 区域，二是鼓励大家把屏幕充满，包括底部。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/full.png" alt=""><br><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/6E1F1B97-EBBC-423B-A329-636F42A71ED3.png" alt=""></p><p>这里的 SheetView 应该符合哪种情况呢？仔细听设计指南后发现，两种说法是在讨论不同情况时候出现的：一是讨论 button 和手势，二是讲到 TableView 时提到。而且，谈到第二种情况时，视频也指出应该把 TableView 和 CollectionView 这类控件充满屏幕。</p><p>我又担心这些还不够证明结论，我又再次看了一下系统层的 AlertSheet 是怎么实现的。答案更支撑了我的结论。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0010/ablum.png" alt=""></p><p>因而，iPhone X 的底部设计既需要考虑避免用户误触，也需要尽可能的把内容填充屏幕。个人结论：<strong>如果控件不具有内容属性，那不应该覆盖住 Home 区域</strong></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>以上是我适配 iPhone X 的一些总结。如有错误欢迎及时指出。</p><p>更多个人分享，可以瞧瞧我不怎么更新的技术博客：<a href="blog.ioshub.cn">iOSHub</a>。当然还有非技术的<a href="zhuanlan.zhihu.com/chantalk">ChanTalk</a>。</p><hr><p>参考链接：</p><ul><li><a href="https://developer.apple.com/videos/play/fall2017/201/" target="_blank" rel="external">Building Apps for iPhone X</a></li><li><a href="https://developer.apple.com/videos/play/fall2017/801/" target="_blank" rel="external">Designing for iPhone X</a></li><li><a href="https://developer.apple.com/ios/human-interface-guidelines/overview/" target="_blank" rel="external">Themes - Overview - iOS Human Interface Guidelines</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果终于在一年一度的秋季发布会发布了 iPhone 十周年纪念版：iPhone X。&lt;/p&gt;
&lt;p&gt;iPhone X 是 2014 发布 iPhone 6 之后又一次外形的变化，也是 iPhone 历史上（可能）最大的一次外观变化。&lt;/p&gt;
&lt;p&gt;我相信很多开发者和设计师看到 iPhone X  的这个「天猫内定」屏幕的时候心里十分苦恼：该怎么为这个机型做设计和适配？这篇文章从苹果的 iPhone X 开发和设计指南出发，试图来解决这个问题。&lt;/p&gt;
&lt;p&gt;需要注意的是，本文不对设计指南完整的、不保留的搬运，而是根据指南和个人实操，做出的结论。完整的内容请自行查看文末链接。如有错误欢迎指出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS, 开发, iOS新特性" scheme="http://yoursite.com/tags/iOS-%E5%BC%80%E5%8F%91-iOS%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>MoSplash 使用帮助</title>
    <link href="http://yoursite.com/2017/08/10/0009/"/>
    <id>http://yoursite.com/2017/08/10/0009/</id>
    <published>2017-08-09T23:25:00.000Z</published>
    <updated>2017-08-17T23:57:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Q1：加载、下载速度较慢"><a href="#Q1：加载、下载速度较慢" class="headerlink" title="Q1：加载、下载速度较慢"></a>Q1：加载、下载速度较慢</h1><p>MoSplash 的后台服务器在美国，访问速度受到你本地服务商的影响多少有一些变化。如果出现图片加载速度较慢时，有以下建议：</p><ul><li>使用梯子，这样访问速度会有提高</li><li>使用收藏，暂时把图片收藏下来</li><li>使用分享，把图片分享到电脑上下载</li></ul><a id="more"></a><h1 id="Q2：MoSplash-的「隐藏操作」？"><a href="#Q2：MoSplash-的「隐藏操作」？" class="headerlink" title="Q2：MoSplash 的「隐藏操作」？"></a>Q2：MoSplash 的「隐藏操作」？</h1><ul><li><p>摇一摇<br>你可以在 MoSplash 的主界面上摇一摇，会出现一张随机壁纸哦～</p></li><li><p>Handoff<br>在 MoSplash 的图片详情页里，是支持 Handoff 的。如果你有两台苹果设备在同一个 Wifi 下，Handoff 可以直接共享这张照片。</p></li><li><p>3D Touch<br>MoSplash 支持 3D Touch。如果你使用 6s 或 7，可以使用 3D Touch 做更多操作。</p></li><li><p>URL Scheme<br>MoSplash 支持使用 URL Scheme 唤醒应用。目前支持三个 URL Scheme：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mosplash://home</div><div class="line">mosplash://liked</div><div class="line">mosplash://random</div></pre></td></tr></table></figure></li></ul><h1 id="Q3：MoSplash-开源了吗？"><a href="#Q3：MoSplash-开源了吗？" class="headerlink" title="Q3：MoSplash 开源了吗？"></a>Q3：MoSplash 开源了吗？</h1><p>MoSplash 不会完整开源。不过我会陆续开源一些我在其中用的技术和技巧。可以在 blog.ioshub.cn 中留意我的分享。</p><h1 id="Q4：MoSplash-只有-iOS-版本吗？"><a href="#Q4：MoSplash-只有-iOS-版本吗？" class="headerlink" title="Q4：MoSplash 只有 iOS 版本吗？"></a>Q4：MoSplash 只有 iOS 版本吗？</h1><p>MoSplash 目前上架了 iOS 和小程序版本，后续计划开发 macOS 版本。敬请期待。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Q1：加载、下载速度较慢&quot;&gt;&lt;a href=&quot;#Q1：加载、下载速度较慢&quot; class=&quot;headerlink&quot; title=&quot;Q1：加载、下载速度较慢&quot;&gt;&lt;/a&gt;Q1：加载、下载速度较慢&lt;/h1&gt;&lt;p&gt;MoSplash 的后台服务器在美国，访问速度受到你本地服务商的影响多少有一些变化。如果出现图片加载速度较慢时，有以下建议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用梯子，这样访问速度会有提高&lt;/li&gt;
&lt;li&gt;使用收藏，暂时把图片收藏下来&lt;/li&gt;
&lt;li&gt;使用分享，把图片分享到电脑上下载&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MoSplash, 教程" scheme="http://yoursite.com/tags/MoSplash-%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MoSplash 技术开源：iOS 文件下载器是怎么实现的（二）</title>
    <link href="http://yoursite.com/2017/08/06/0008/"/>
    <id>http://yoursite.com/2017/08/06/0008/</id>
    <published>2017-08-06T11:41:00.000Z</published>
    <updated>2017-08-06T11:41:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇《<a href="http://blog.ioshub.cn/2017/08/06/0007/" target="_blank" rel="external">MoSplash 技术开源：iOS 文件下载器是怎么实现的（一）</a>》里，我讲解了怎么封装 Downloader 这一层，实现了一个单一任务的下载器。但是在很多 App 里，一个下载器并不能满足需求，因而需要封装一个 DownloadManager 类进行下载管理。下载管理和下载器之间怎么对接，下载管理和任务管理之间又怎么对接，这是这篇文章想要解决的问题。</p><a id="more"></a><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>没错，在开始敲代码之前要先对需要封装的类进行思考，分析它需要完成什么样的任务，暴露什么样的接口和属性。FileDownloadManager 的需求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">* Method：</div><div class="line">* shareManager</div><div class="line">* add</div><div class="line">* stop (all or someone)</div><div class="line">* continue(all or someone)</div><div class="line">* fetch</div><div class="line">* Property</div><div class="line">* taskCount:NSUInteger</div><div class="line">* taskArray:NSArray</div><div class="line">* Callback</div><div class="line">* downloadFinish</div><div class="line">* downloadError</div><div class="line">* progress</div></pre></td></tr></table></figure><h1 id="下载管理与下载器对接"><a href="#下载管理与下载器对接" class="headerlink" title="下载管理与下载器对接"></a>下载管理与下载器对接</h1><p>FileDownloadManager 和 Downloader 的功能分类有点像，分别是：操作方法（增加任务、暂停、继续）、Downloader 回调（下载完成、下载进度）、下载管理器 Delegate 回调（下载完成、下载进度），还有获取下载状态。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>这里只分析新建下载任务和暂停某个任务，其他的方法可以在文末的 Demo 中查看。</p><p>新建下载任务的方法实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@interface FileDownloadManager () &lt;JHDownloadDelegate&gt;</div><div class="line">@property (nonatomic, assign) NSUInteger taskCount;</div><div class="line">@property (nonatomic, strong) NSMutableArray &lt;JHDownloader *&gt; *taskArray;</div><div class="line">@end</div><div class="line"></div><div class="line"># pragma mark - 新建下载线程</div><div class="line">+ (void)addTaskWithRequest:(NSURLRequest *)request withDelegate:(id &lt;FileDownloadManagerDelegate&gt;)target&#123;</div><div class="line">    FileDownloadManager *manager = [FileDownloadManager shareManager];</div><div class="line">    // 检查队列中是否存在该任务</div><div class="line">    __block BOOL isExist = NO;</div><div class="line">    __block NSUInteger index;</div><div class="line">    [manager.taskArray enumerateObjectsUsingBlock:^(JHDownloader * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        if([obj.downloadID isEqualToString:request.URL.absoluteString])</div><div class="line">        &#123;</div><div class="line">            isExist = YES;</div><div class="line">            index = idx;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    if(isExist)</div><div class="line">    &#123;</div><div class="line">        [FileDownloadManager continueTaskWithIndex:index];</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    manager.delegate = target;</div><div class="line">    // 创建任务</div><div class="line">    [manager addTaskWithRequest:request];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addTaskWithRequest:(NSURLRequest *)request</div><div class="line">&#123;</div><div class="line">    JHDownloader *downloader = [JHDownloader downloadWithRequest:request andDelegate:self];</div><div class="line">    [_taskArray addObject:downloader];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里使用的 manager 对象是单例对象，在整个生命周期里只会实例化一次。在 <code>addTaskWithRequest:withDelegate:</code> 方法里，对任务数据使用 <code>enumerateObjectsUsingBlock</code> 方法实现异步的遍历，达到更快的遍历效果。</p><p>暂停某个任务的时候，也是对任务数组进行遍历，对对应数组进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (void)stopTaskWithDownloaderID:(NSString *)downloaderID&#123;</div><div class="line">    FileDownloadManager *manager = [FileDownloadManager shareManager];</div><div class="line">    [manager.taskArray enumerateObjectsUsingBlock:^(JHDownloader * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        if([obj.downloadID isEqualToString:downloaderID])</div><div class="line">        &#123;</div><div class="line">            [obj stopDownload];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>值得注意的是，这里的接口方法暴露的都是实例方法，开发者调用这个 API 的时候，不需要实例化就能使用该方法。</p><h2 id="Downloader-回调和-Manager-回调"><a href="#Downloader-回调和-Manager-回调" class="headerlink" title="Downloader 回调和 Manager 回调"></a>Downloader 回调和 Manager 回调</h2><p>在 FileDownloaderManager 的 addTask 接口方法里，我们已经将一个 Downloader 的 delegate 设置成了 Manager 本身，因而可以在该类实现对应的 delegate 回调方法。同时，在 delegate 里实现 Manager 的 delegate，这样就实现了从 Downloader 到 Manager 的回调。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># pragma mark - DownloaderDelegate</div><div class="line">/**</div><div class="line"> * 下载完成</div><div class="line"> */</div><div class="line">- (void)finishDownloadWithResponseData:(NSData *)responseData andDownloader:(JHDownloader *)downloader</div><div class="line">&#123;</div><div class="line">    // 此时下载任务已经完成</div><div class="line">    // 将任务从队列中删除</div><div class="line">    [self.taskArray enumerateObjectsUsingBlock:^(JHDownloader * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        if([obj.downloadID isEqualToString:downloader.downloadID])</div><div class="line">        &#123;</div><div class="line">            [_taskArray removeObject:obj];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    // 回调</div><div class="line">    if([self.delegate respondsToSelector:@selector(taskFinishDownload:withData:)])</div><div class="line">    &#123;</div><div class="line">        [self.delegate taskFinishDownload:downloader withData:responseData];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 下载进程</div><div class="line"> */</div><div class="line">-(void)downloadingWithProgress:(float)progress andDownloader:(JHDownloader *)downloader</div><div class="line">&#123;</div><div class="line">    if([self.delegate respondsToSelector:@selector(taskDownloadingWithProgress:andDownloader:)])</div><div class="line">    &#123;</div><div class="line">        [self.delegate taskDownloadingWithProgress:progress andDownloader:downloader];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>至此就完成了一个 DownloadManager 的封装。开发者在使用下载器的时候，可以使用 DownloadManager 的接口方法添加一个任务，同时，将 Manager 的 delegate 设置到正确的类当中。这样就完成了下载器的统一管理和使用。</p><h1 id="But……"><a href="#But……" class="headerlink" title="But……"></a>But……</h1><p>在 MoSplash 里，下载图片的时候可以同时设定要不要裁剪图片，裁剪大小是怎么样的。这样，一个下载任务的产生同时还包含着一个图片操作任务。怎样把图片操作任务和下载任务结合，怎样把操作管理和 UI 和其他层互相调用，这些将在《MoSplash 技术开源：iOS 文件下载器是怎么实现的（三）》中进行分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇《&lt;a href=&quot;http://blog.ioshub.cn/2017/08/06/0007/&quot;&gt;MoSplash 技术开源：iOS 文件下载器是怎么实现的（一）&lt;/a&gt;》里，我讲解了怎么封装 Downloader 这一层，实现了一个单一任务的下载器。但是在很多 App 里，一个下载器并不能满足需求，因而需要封装一个 DownloadManager 类进行下载管理。下载管理和下载器之间怎么对接，下载管理和任务管理之间又怎么对接，这是这篇文章想要解决的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MoSplash, 教程, iOS, 技术" scheme="http://yoursite.com/tags/MoSplash-%E6%95%99%E7%A8%8B-iOS-%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>MoSplash 技术开源：iOS 文件下载器是怎么实现的（一）</title>
    <link href="http://yoursite.com/2017/08/06/0007/"/>
    <id>http://yoursite.com/2017/08/06/0007/</id>
    <published>2017-08-06T10:24:00.000Z</published>
    <updated>2017-08-06T11:41:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>7 月份 MoSplash 升级到了 2.0 的版本，这个版本最大的更新是优化了整个 App 的下载体验。从产品上来看，MoSplash 下载更加稳定、支持断点续传、支持后台下载、支持暂停取消等。从代码来看，这些功能都得益于 MoSplash 在 2.0 版本封装了一个文件下载层和图片操作管理器，解耦了这部分逻辑后，体验得到提升。今天来讲讲怎么封装文件下载器。</p><a id="more"></a><h1 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h1><p>封装文件下载器可以选择苹果的 NSURLConnection 或者 NSURLSession，或选择第三方框架 AFNetwork 等。</p><p>NSURLConnection 是 iOS9之前的网络库，iOS9 之后已经被弃用，如果你的应用还需要支持 iOS9 以下的版本的话， 应该使用 NSURLConnection 或旧版本的 AFNetwork。</p><p>AFNetwork 3.0 实际上是对 NSURLSession 的封装。而且在文件下载方面的封装十分简单粗暴。如果你的项目的网络库都是基于 AFNetwork 封装的，那么文件下载器也可以考虑使用  AFNetwork。</p><p>MoSplash 是基于 NSURLSession 封装的文件下载器。本文也将以 NSURLSession 为例，讲解封装 FileDownloader。</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>动手敲代码之前，我们先需要思考一个文件下载器需要哪些「功能」，换句话说，就是 FileDownloader 在接口文件需要暴露哪些 API。下面是常见的属性和接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">* Method：</div><div class="line">* start</div><div class="line">* stop</div><div class="line">* continue</div><div class="line">* Property</div><div class="line">* isDownloading:BOOL</div><div class="line">* downloadID:NSString</div><div class="line">* Callback</div><div class="line">* downloadFinish</div><div class="line">* downloadError</div><div class="line">* progress</div></pre></td></tr></table></figure><p>以上三部分可以对应接口中的方法、属性和 Delegate。这就是一个 FileDownloader 的接口。一个 FileDownloader 就是一个下载任务，在有些应用里，下载任务可能不止一个，需要有多个下载器共同来完成，这就需要在 Downloader 之上封装一层 DownloadManager。同样的，分析它的属性和接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">* Method：</div><div class="line">* shareManager</div><div class="line">* add</div><div class="line">* stop (all or someone)</div><div class="line">* continue(all or someone)</div><div class="line">* fetch</div><div class="line">* Property</div><div class="line">* taskCount:NSUInteger</div><div class="line">* taskArray:NSArray</div><div class="line">* Callback</div><div class="line">* downloadFinish</div><div class="line">* downloadError</div><div class="line">* progress</div></pre></td></tr></table></figure><p>Manager 将在《MoSplash 技术开源：iOS 文件下载器是怎么实现的（二）》中讲解。</p><h1 id="FileDownloader-实现"><a href="#FileDownloader-实现" class="headerlink" title="FileDownloader 实现"></a>FileDownloader 实现</h1><p>一个下载器可以分成这样几部分：操作方法（增加任务、暂停、继续）、NSURLSession 回调（下载完成、下载进度）、下载器 Delegate 回调（下载完成、下载进度）</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>使用接口方法新建一个下载器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface JHDownloader()&lt;NSURLSessionDelegate&gt;</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSURLSessionDownloadTask *downloadTask;</div><div class="line">@property (nonatomic, strong) NSURLSession *backgroundURLSession;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">+ (instancetype)downloadWithRequest:(NSURLRequest *)request andDelegate:(id &lt;JHDownloadDelegate&gt;)target&#123;</div><div class="line">    JHDownloader *downloader = [[JHDownloader alloc]init];</div><div class="line">    downloader.downloadID = request.URL.absoluteString;</div><div class="line">    downloader.downloadDelegate = target;</div><div class="line">    downloader.downloadTask = [downloader.backgroundURLSession downloadTaskWithRequest:request];</div><div class="line">    [downloader.downloadTask resume];</div><div class="line">    downloader.isDownloading = YES;</div><div class="line">    return downloader;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">#pragma mark -- getter and setter</div><div class="line">- (NSURLSession *)backgroundURLSession &#123;</div><div class="line">    if(!_backgroundURLSession)&#123;</div><div class="line">        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:[NSString stringWithFormat:@&quot;%@&quot;,_downloadID]];</div><div class="line">        _backgroundURLSession = [NSURLSession sessionWithConfiguration:sessionConfig</div><div class="line">                                                delegate:self</div><div class="line">                                           delegateQueue:[NSOperationQueue mainQueue]];</div><div class="line">    &#125;</div><div class="line">    return _backgroundURLSession;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此处，JHDownloadDelegate 是下载器下载完成和下载进度的回调。如果是单一任务，那么可以设置 delegate 为 ViewController。如果 App 内有多个任务，可以设置 delegate 为 DownloadManger，然后在 Manager 内将信息传过去。</p><p>backgroundURLSession 的 downloadTaskWithRequest 方法可以生成一个 NSURLSessionDownloadTask， 使用 <code>[downloader.downloadTask resume]</code> 则可以开始任务。</p><p>任务的暂停和下载接口实现就比较简单了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)continueDownload&#123;</div><div class="line">    [self.downloadTask resume];</div><div class="line">    self.isDownloading = YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)stopDownload&#123;</div><div class="line">    [self.downloadTask suspend];</div><div class="line">    self.isDownloading = NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="NSURLSession-回调"><a href="#NSURLSession-回调" class="headerlink" title="NSURLSession 回调"></a>NSURLSession 回调</h2><p>NSURLSession 的 Getter 里，设置任务 delegate 的为当前的下载器，在 Downloader 里实现 NSURLSessionDelegate 的两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> 当一个下载task任务完成以后，这个方法会被调用。我们可以在这里移动或者复制download的数据</div><div class="line"> */</div><div class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line"> 获取下载进度</div><div class="line"> */</div><div class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">      didWriteData:(int64_t)bytesWritten</div><div class="line"> totalBytesWritten:(int64_t)totalBytesWritten</div><div class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这两个方法比较容易理解。获取下载进度方法中，每个 int64_t 的参数分别代表：已写入磁盘的数据大小、已下载数据大小、文件总大小，可以用这些数据来计算下载完成度。</p><h2 id="下载器-Delegate-回调"><a href="#下载器-Delegate-回调" class="headerlink" title="下载器 Delegate 回调"></a>下载器 Delegate 回调</h2><p>JHDownloadDelegate 里有三个可选回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@class JHDownloader;</div><div class="line">@protocol JHDownloadDelegate &lt;NSObject&gt;</div><div class="line">@optional</div><div class="line">-(void)finishDownloadWithResponseData:(NSData *)responseData andDownloader:(JHDownloader *)downloader;</div><div class="line"></div><div class="line">-(void)downloadingWithProgress:(float)progress andDownloader:(JHDownloader *)downloader;</div><div class="line">@end</div></pre></td></tr></table></figure><p>分别写到实现文件中去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> 当一个下载task任务完成以后，这个方法会被调用。我们可以在这里移动或者复制download的数据</div><div class="line"> */</div><div class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location&#123;</div><div class="line">    NSData *data = [NSData dataWithContentsOfURL:location];</div><div class="line">    // 传递已经下载的数据用于保存</div><div class="line">    if([self.downloadDelegate respondsToSelector:@selector(finishDownloadWithResponseData: andDownloader:)])</div><div class="line">    &#123;</div><div class="line">        [self.downloadDelegate finishDownloadWithResponseData:data andDownloader:self];</div><div class="line">    &#125;</div><div class="line">    self.isDownloading = NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line"> 获取下载进度</div><div class="line"> */</div><div class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">      didWriteData:(int64_t)bytesWritten</div><div class="line"> totalBytesWritten:(int64_t)totalBytesWritten</div><div class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123;</div><div class="line">    if([self.downloadDelegate respondsToSelector:@selector(downloadingWithProgress:andDownloader:)])</div><div class="line">    &#123;</div><div class="line">        [self.downloadDelegate downloadingWithProgress:((float)totalBytesWritten/(float)totalBytesExpectedToWrite) andDownloader:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 下载失败</div><div class="line"> */</div><div class="line">- (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(nullable NSError *)error</div><div class="line">&#123;</div><div class="line">    if([self.downloadDelegate respondsToSelector:@selector(finishWithError:)])</div><div class="line">    &#123;</div><div class="line">        [self.downloadDelegate finishWithError:error];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>至此，一个文件下载器就完成了封装。《<a href="http://blog.ioshub.cn/2017/08/06/0008/" target="_blank" rel="external">MoSplash 技术开源：iOS 文件下载器是怎么实现的（二）</a>》将介绍封装 DownloadManager。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;7 月份 MoSplash 升级到了 2.0 的版本，这个版本最大的更新是优化了整个 App 的下载体验。从产品上来看，MoSplash 下载更加稳定、支持断点续传、支持后台下载、支持暂停取消等。从代码来看，这些功能都得益于 MoSplash 在 2.0 版本封装了一个文件下载层和图片操作管理器，解耦了这部分逻辑后，体验得到提升。今天来讲讲怎么封装文件下载器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MoSplash, 教程, iOS, 技术" scheme="http://yoursite.com/tags/MoSplash-%E6%95%99%E7%A8%8B-iOS-%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git 入门指北</title>
    <link href="http://yoursite.com/2017/07/20/0006/"/>
    <id>http://yoursite.com/2017/07/20/0006/</id>
    <published>2017-07-20T01:15:00.000Z</published>
    <updated>2017-07-26T01:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>前两天给工作室里大一的小朋友讲了一遍 Git 的基础知识，趁着还能记得，想把这样的分享记录下来，整理成一遍文章。演讲用的 keynote 在此：<a href="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/Git%20基础.key" target="_blank" rel="external">点击下载</a>。演讲大纲如下：</p><ul><li>Git 是什么</li><li>Git 怎么用</li><li>Git 与团队协作</li></ul><a id="more"></a><h1 id="Git-是什么"><a href="#Git-是什么" class="headerlink" title="Git 是什么"></a>Git 是什么</h1><p>在回答 Git 是什么这个问题之前，我们首先需要知道版本控制是什么？</p><p>版本控制其实很好理解， 版本控制系统就是对一个文件、文件系统的历史节点版本进行保存、回退等控制管理的系统。</p><p>在 Mac 里，很多原生的应用都会自带一个我们理解的版本控制系统。就拿 keynote 为例子，打开一份 keynote 文件，点击 文件-&gt;复原到…-&gt;浏览所有版本，可以看到这样的一个界面。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/WechatIMG102.jpeg" alt=""></p><p>这就是 Mac 应用里自带的版本控制系统，我们可以在右边的时间轴里随时找回此文件的不同历史版本，恢复到历史的某个版本来。</p><p>那么在代码版本管理这里，我们用的是什么工具呢？在以前，CVS 和 SVN 都是比较流行版本控制系统，直到 Git 开始流行之前，SVN 还是一个是十分广泛使用的版本控制。SVN 与 Git 的差别是，SVN 是一种集中式的版本控制系统，而 Git 是一种分布式的版本控制系统。</p><p>有些刚入门的小朋友很容易搞混的两个概念是「Git」和「GitHub」。Git 的概念如上文所述，而 GitHub 呢，实际上可以理解成一个社区，一个开源（当然也有一部分不开源的）代码的社区。在 GitHub 这个社区里，大家使用 Git 这个工具，将自己的代码共享到 GitHub 中去。当然 GitHub 在使用 Git 的时候也和基本的 Git 有一些区别，这些以后再讲。</p><h1 id="Git-怎么用"><a href="#Git-怎么用" class="headerlink" title="Git 怎么用"></a>Git 怎么用</h1><p>讲完了 Git 的作用，我们来讲讲 Git 的使用。 </p><h2 id="先了解几个概念"><a href="#先了解几个概念" class="headerlink" title="先了解几个概念"></a>先了解几个概念</h2><p>首先，在讲解 Git 使用之前，我觉得你必须掌握「终端模拟器」这个工具。</p><p>打开 Spotlight， 搜索『终端』或者「terminal」，就可以打开 Mac 上的终端模拟器。在终端模拟器里运行着一个叫做 shell 的软件。shell（「壳」的意思）这个软件会和计算机的内核进行通讯，用户通过在界面输入命令，达到和计算机进行通讯的功能。</p><p>Git 的命令行使用需要用到 Terminal。在 Terminal 中输入 <code>git &lt;命令&gt;</code> 如 <code>git status</code> 即可执行一条 git 命令。</p><p>接着讲讲 Git 使用前还需要了解的 Git 知识：Git 的四个区和 Git 分支。</p><p>当我们初始化一个 Git 之后，我们会得到一个 Git 的版本库。Git 中，用四个区，分别是「工作目录」、「暂存区」、「本地版本」、「远端版本」。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/QQ20170720-094243.png" alt=""></p><p>工作目录是程序员平时在 IDE 里修改代码的时候实际工作的区域。当我们修改文件的时候，直接影响到了工作目录下的文件。当我们使用 <code>git add</code> 时，可以将工作目录下的文件版本同步到暂存区里去，使用 <code>git commit</code> 命令，则可以将代码发布到本地仓库中去。这样就完成了本地代码的一次更新。使用 <code>git push</code> 则可以将本地的代码发送到远端仓库中去，这样你就可以和同伴们共享自己修改的代码了。</p><p>Git 分支实际上也是一个比较好理解的概念。当我们创建一个 Git 仓的时候，默认会生成一个 master 分支。在我们平时开发过程中，我们可能需要添加某些功能，可能每个人负责的功能不同，那么我们会在一个节点上，开出几个不同的分支，当我们开发完毕的时候再把它们合并在一起。这是分支使用的一个例子。</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/QQ20170720-094926.png" alt=""></p><h2 id="Git-的基本命令"><a href="#Git-的基本命令" class="headerlink" title="Git 的基本命令"></a>Git 的基本命令</h2><p>终于要开始使用 Git 了。首先你需要安装 Git，如果你已经安装了最新的 Xcode，那恭喜你，你也已经安装好了 Git。如果你的 Mac 没有 Xcode，我倒是建议你安装一个。</p><p>Git 的基本命令我觉得有如下几条：</p><ul><li>添加与提交</li></ul><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/QQ20170720-095502.png" alt=""></p><ul><li>推送改动</li></ul><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/QQ20170720-095538.png" alt=""></p><ul><li>分支操作</li></ul><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/QQ20170720-095557.png" alt=""></p><ul><li>其他操作</li></ul><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/QQ20170720-095624.png" alt=""></p><h2 id="怎样开始一个-Git-项目？"><a href="#怎样开始一个-Git-项目？" class="headerlink" title="怎样开始一个 Git 项目？"></a>怎样开始一个 Git 项目？</h2><p>讲解一个东西最直观的方法还是开始一个 Demo。下面将演示一下 Git 使用的几个不同场景。</p><ul><li>本地-&gt;远端</li><li>远端-&gt;本地</li><li>分支操作</li><li>冲突解决</li></ul><p>前面两点解决的是「怎么开始一个 Git 项目」，分别从两种场景来讲。后面两点是解决 Git 使用过程会遇到的两个场景。</p><ul><li>本地-&gt;远端<br>在本地创建一个空的 Git 仓库，需要使用 <code>git init</code> 命令。在终端中，使用 <code>cd &lt;目录&gt;</code> 进入你想要工作的空目录，在改目录下使用 <code>git init</code> 命令创建一个空的 Git 仓库。</li></ul><p>创建仓库后，在 finder 查看该目录好像并没有什么变化。那是因为 <code>git init</code> 执行之后创建了一个隐藏的 .git 文件，在 finder 里默认是无法查看的。使用 <code>ls -ah</code> 命令可以在 终端里查看到该目录下的隐藏文件和文件夹。</p><p>接着，你就可以在工作目录下添加、修改你的代码。当你在编译器或者 IDE 里完成了修改之后，可以使用 <code>git add *</code> 将代码同步到暂存区中（还记得吧，这是第二个区），当你确定要提交这个代码版本到本地仓库时，使用 <code>git commit -m &lt;提交信息&gt;</code> 将此时的代码同步到本地仓库中去。为了方便了解本次提交修改或者添加了什么内容，提交信息需要填写本次提交的基本信息。关于提交信息的书写规范，在下文会描述。</p><p>OK，这样你的本地仓库就有你最新的代码了。接着，你需要将本地的代码发布到远程仓库中，这样你就可以和你的同伴一起协作开发了。首先你需要添加一个远程仓库 <code>git remote add origin &lt;server&gt;</code> 然后使用 <code>git push origin master</code> 就可以将 master 分支 push 到 origin 远端仓库中。</p><ul><li>远端-&gt;本地</li></ul><p>从远端将代码拉动到本地需要用 <code>git clone &lt;server&gt;</code> 将远程的仓库下载到本地。完成修改之后，可以用上文相同的方式将代码同步到远程。</p><ul><li>分支操作</li></ul><p>在 Git 里面管理代码一定离不开分支的操作。常见的分支操作包括创建新的分支、检出分支、合并分支。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">／／ 创建并检出新的分支</div><div class="line">git checkout -b search</div><div class="line">／／ 切换分支</div><div class="line">git checkout master</div><div class="line">／／ 查看分支情况</div><div class="line">git branch</div><div class="line">／／ 合并分支</div><div class="line">git merge search</div></pre></td></tr></table></figure><ul><li>合并冲突</li></ul><p>「冲突」在新手听起来可能是一件可怕的事情，但其实当我们遇到并解决它的时候并没有那么可怕。冲突的产生往往是因为两个不同的分支在不同的节点里进行了不一样的操作。当操作者把这两条分支合并在一起的时候，Git 并不知道要保留哪个分支下的版本，于是就产生了一个冲突。</p><p>产生冲突的文件会以下格式的代码出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</div><div class="line">master hahahah</div><div class="line">=======</div><div class="line">search hahahahh</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; search</div></pre></td></tr></table></figure><p>新手看到这个可能有点怕，但是不用担心，这个东西很容易。在这个文件的这段代码代表：在当前分支下的代码为 <code>master hahahah</code> 在 search 这个分支下，代码则是 <code>search hahahahh</code>，请解决这个冲突。解决办法也很简答，你只要删除其中一个就可以。比如我想保留 HEAD 下的版本，那么只留下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">master hahahah</div></pre></td></tr></table></figure><p>OK，然后使用 commit 命令提交代码即可。</p><ul><li>Git 的其他操作</li></ul><p>Git 还有很多其他操作。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git tag</div><div class="line">git stash</div><div class="line">git status</div><div class="line">git reset</div></pre></td></tr></table></figure><p>这些一般我会使用可视化的工具 SourceTree 里管理，所以这里也不多累赘。</p><ul><li>重要</li></ul><p>我使用 Git 里有一句我觉得挺重要的结论，就是：<strong>Git 的高级操作是由基本操作组合完成的</strong>。掌握基本命令并灵活使用，可以完成 Git 的高级操作，比如说删除分支的某次提交。</p><h1 id="Git-与团队协作"><a href="#Git-与团队协作" class="headerlink" title="Git 与团队协作"></a>Git 与团队协作</h1><p>OK，终于到了 Git 的实战阶段。我们使用 Git 很多时候和同伴一起使用。在 Git 中有着一些大家默认遵守的 Git 使用和管理的方法，使用这样的方法可以让我们的代码管理更加有条有理。有以下两点：</p><ul><li>Git Flow</li><li>Git Commit</li></ul><h2 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h2><p>狭义来讲，Git Flow 是指 Git 的分支管理方法。如果不加以管理，团队在提交代码的时候，可能会不知道远端仓库的情况</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/WechatIMG103.jpeg" alt=""></p><p>使用规范的 Git Flow，可以做到规范的提交 Git 分支，如下：</p><p><img src="http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/WechatIMG110.jpeg" alt=""></p><p>每个分支的功能都不同：</p><ul><li><p>master——最为稳定功能最为完整的随时可发布的代码；<br>这个分支只能从其他分支合并，不能在这个分支直接修改</p></li><li><p>develop——永远是功能最新最全的分支；<br>这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支</p></li><li><p>hotfix——修复线上代码的 bug；<br>当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release</p></li><li><p>feature——某个功能点正在开发阶段；<br>这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release</p></li><li><p>release——发布定期要上线的功能。<br>当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支</p></li></ul><p>更多详情的介绍，可以查看文末的链接。</p><h2 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a>Git Commit</h2><p>Git Commit 是对 Git 的提交信息进行规范的一种约定。方便开发协作者查看每次修改的内容和重要性。具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Header</div><div class="line">feat：新功能（feature）</div><div class="line">fix：修补bug</div><div class="line">docs：文档（documentation）</div><div class="line">style： 格式（不影响代码运行的变动）</div><div class="line">refactor：重构（即不是新增功能，也不是修改bug的代码变动）</div><div class="line">test：增加测试</div><div class="line">chore：构建过程或辅助工具的变动</div><div class="line"></div><div class="line">Body</div><div class="line">Footer</div></pre></td></tr></table></figure><p>同样的， Git Commit 的更多内容可以查看文末链接。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的 Git 教程</a></li><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">Git Pro</a></li><li><a href="rogerdudler.github.io/git-guide/index.zh.html">Git 简明教程</a></li><li><a href="blog.yvesluo.cc/2017/01/25/GitFlow/">Git Flow</a></li><li><a href="blog.yvesluo.cc/2017/01/25/Git之正确的commit姿势/">Git Commit</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天给工作室里大一的小朋友讲了一遍 Git 的基础知识，趁着还能记得，想把这样的分享记录下来，整理成一遍文章。演讲用的 keynote 在此：&lt;a href=&quot;http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0006/Git%20基础.key&quot;&gt;点击下载&lt;/a&gt;。演讲大纲如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git 是什么&lt;/li&gt;
&lt;li&gt;Git 怎么用&lt;/li&gt;
&lt;li&gt;Git 与团队协作&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Git, 开发工具" scheme="http://yoursite.com/tags/Git-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>MoSplash 开发日记（1）：被苹果拒绝后，我做了些什么</title>
    <link href="http://yoursite.com/2017/03/22/0005/"/>
    <id>http://yoursite.com/2017/03/22/0005/</id>
    <published>2017-03-22T01:42:00.000Z</published>
    <updated>2017-03-22T01:42:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>MoSplash 是我第一个独立开发的项目。想成为独立开发者这个想法是在去年，希望自己独立完成一个 APP 并上架，最后终于在今年二月开始了 MoSplash 的独立设计与开发。</p><p>本来想在 MoSplash 正式上架之后再以一篇文章的形式介绍一下，结果没想到第一次上架就苹果审核为不通过。着实有点沮丧。从 MoSplash 提交审核到被决绝期间发生了什么，我决定用一篇文章的方式记录下来。</p><p><img src="/img/0004/MoSplash.png" alt=""></p><a id="more"></a><h2 id="两次被拒"><a href="#两次被拒" class="headerlink" title="两次被拒"></a>两次被拒</h2><blockquote><p>The support URL specified in your app’s metadata does not properly navigate to the intended destination. </p></blockquote><p>第一次提交时，项目的开发人员网站我填写的是我的微博地址，直接被拒绝了。</p><blockquote><p>Thank you for your resubmission. We discovered one or more bugs in your app when reviewed on iPad and iPhone running iOS 10.2.1 on Wi-Fi connected to an IPv6 network.</p></blockquote><p>苹果在 iOS 9 之后要求开发者对应用进行 IPv6 only 的适配。如果出现这种问题，请检查项目的所有网络请求是不是适配了 IPv6 only。</p><blockquote><p>Please revise your app concept to provide a more robust user experience by including native iOS features and functionality.</p></blockquote><p>主要的 App 提供的功能太少，苹果不允许支持包装 Web App 的应用上架。</p><h2 id="程序的改动"><a href="#程序的改动" class="headerlink" title="程序的改动"></a>程序的改动</h2><ul><li><p>升级所有第三方库，支持 IPv6<br>AFNetwork（3.0）、SDWebImage（3.8)支持了 IPv6</p></li><li><p>支持更多原生功能和交互，如 3D Touch</p></li><li>优化交互和用户体验</li></ul><h2 id="产品设计的思考"><a href="#产品设计的思考" class="headerlink" title="产品设计的思考"></a>产品设计的思考</h2><p>不得不说，第一次接受苹果的审核让我感触最多的一点就是他们的产品定位的执着。</p><blockquote><p>Please revise your app concept to provide a more robust user experience by including native iOS features and functionality. </p></blockquote><p>MoSplash 1.0 的版本在功能上确实很简单，因为我希望 MoSplash 可以得到长期的维护，听取用户的声音之后升级到更多的功能。没想到上架的第一个版本就被拒绝。被拒绝两次之后，我才开始思考 MoSplash 的定位和走向。</p><p>1.0 版本的 MoSplash 提供了 Unsplash 无版权图片的高清下载、预览等体验，支持了 3D Touch 预览、摇一摇随机图片，同时支持收藏壁纸。我只花费一个半星期的时间就完成了设计和开发。</p><p>在做 MoSplash 之前我做的几个 iOS 项目要不就是不需要我亲自上架，要不就是根本没上架。做出来的产品都是「能用即可」，而开发者做的事情一般都是先做出 Demo 测试然后改进体验。</p><p>在 App Store 上架的 App 要求开发者一开始就应该注意用户体验。苹果 App 审查中，有一条给我的审核反馈是：「In addition, we noticed that the download button is not responsive」，我仔细思考了之后觉得有两种可能，一是点击下载时，由于原图过大导致看上去加载停止了（虽然我已经做了进度条），二是下载按钮的可点击区域较小，导致了点击不灵敏。</p><p>OMG，这种体验上的一个问题审核员都要把它指出来！以前我一直以为 App 审核莫过于审查 App 的安全性等问题，接触过苹果 App 审核之后我才意识到之前的想法实在是 Naive。</p><p>接下来一段时间 MoSplash 将定位「无版权高清图库工具」这样一款移动端的图库应用，在功能、体验上进行改进，可能不会在 App Store 快速上架，<strong>在此对之前已经拿到内测资格的朋友说声抱歉， MoSplash 跳票了。</strong></p><h2 id="收费模式的思考"><a href="#收费模式的思考" class="headerlink" title="收费模式的思考"></a>收费模式的思考</h2><p>MoSplash 计划中的定价是 6 元人民币的冰点价格，维护一段时间之后升价到 12 或 18 元人民币。</p><p>参考了一下服务器相关的成本和图库 API 的费用。我考虑改变 MoSplash 的收费方式：<strong>MoSplash 将免费下载，高级功能需内购</strong>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>第一次公布 MoSplash 内测的时候收到了很多朋友的鼓励和支持，让我信心倍增。重新思考后出发的 MoSplash 会提高应用的完整性，再选择在 App Store 上架。<strong>我不会放弃独立开发之路</strong>，也会更有自信地完成这个作品。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MoSplash 是我第一个独立开发的项目。想成为独立开发者这个想法是在去年，希望自己独立完成一个 APP 并上架，最后终于在今年二月开始了 MoSplash 的独立设计与开发。&lt;/p&gt;
&lt;p&gt;本来想在 MoSplash 正式上架之后再以一篇文章的形式介绍一下，结果没想到第一次上架就苹果审核为不通过。着实有点沮丧。从 MoSplash 提交审核到被决绝期间发生了什么，我决定用一篇文章的方式记录下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/0004/MoSplash.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="独立开发" scheme="http://yoursite.com/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>我开始写技术博客了，还做了些其他事情</title>
    <link href="http://yoursite.com/2017/03/18/0004/"/>
    <id>http://yoursite.com/2017/03/18/0004/</id>
    <published>2017-03-18T02:18:00.000Z</published>
    <updated>2017-03-22T01:45:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 ChanTalk、iOSHub 和独立开发。</p><a id="more"></a><h2 id="ChanTalk"><a href="#ChanTalk" class="headerlink" title="ChanTalk"></a>ChanTalk</h2><p>ChanTalk 是我的第一个个人博客，依然记得 ChanTalk 的第一篇文章是我进入大学的前一天，在担心着自己进入大学之后有一段时间没有网络可以使用，以及对第一次写博客的欣喜，这两种复杂的心情，我发布了第一篇博客《<a href="http://chanjh.com/post/view/0000" title="先于时代还是慢于时代？——Smartisan OS 2.0轻体验" target="_blank" rel="external"> 先于时代还是慢于时代？——Smartisan OS 2.0轻体验 </a>》。</p><p>进入大学之后，我对自己更新博客的要求是「至少每两周一更」，除了在某些比较忙碌的月份更新速度跟不上之外，大部分时间 ChanTalk 都能保持更新。</p><p>博客内容也开始有了一些定位。ChanTalk 创立的初衷就像 slogan 表达的一样：「记录思考，分享创意」，在 ChanTalk 里分享的是我日常阅读、玩机之后的心得和一些小小的创意，不局限自己的想象力，不刻意塑造一个很极客的博客。</p><p>ChanTalk 的文章里最火的是《<a href="http://chanjh.com/post/software/0012" target="_blank" rel="external">Mac 下使用 Aria2 实现迅雷离线和百度云下载</a>》不知道被谁分享到豆瓣、机锋等地方之后，阅读量和点赞数量就不断上升。之后，像《<a href="http://chanjh.com/post/software/0020" target="_blank" rel="external">iOS 10 PB 初体验——也许你该升级设备了</a>》这样注重体验、《<a href="http://chanjh.com/post/life/0023" target="_blank" rel="external">我是怎么管理密码的</a>》这样注重创意的文章也都有比较高的阅读量。而像《<a href="http://chanjh.com/post/developer/0024" target="_blank" rel="external">程序员应该写怎样的博客</a>》和《<a href="http://chanjh.com/post/developer/0026" target="_blank" rel="external">软件开发的理与美——记 iOS Club 之行</a>》这样写给程序员看的文章，阅读量则比较少。</p><p>ChanTalk 的定位还是那一句话：「记录思考，分享创新」，只是方向从 Aria2c 的教程开始便有了一些改变，便是更加注重数字生活的体验，而开始远离程序员的日常。</p><p>可是我还是一名程序员啊，一名程序员怎能不写写程序员的事情？因此，搭建自己的技术博客成为我必须做的一件事情。</p><h2 id="iOSHub"><a href="#iOSHub" class="headerlink" title="iOSHub"></a>iOSHub</h2><p><img src="http://chanjh.b0.upaiyun.com/0027/ioshub.jpg" alt=""></p><p><a href="blog.ioshub.cn">iOSHub</a> 实际上从去年开始我的一个设想。<a href="blog.ioshub.cn">iOSHub</a> 的理想状态并不是一个个人博客而已。她的理想状态是集碎片化知识、博客书籍等形式，内容包含开发、设计等与 iOS 关于的一个网站。要实现她的理想状态还有一个遥远的距离，也不知道是否可以真的实现，只能这是个我的一个目标。</p><p><a href="blog.ioshub.cn">iOSHub</a> 的主题是分享开发中的理与美。就像在《<a href="http://chanjh.com/post/developer/0024" target="_blank" rel="external">程序员应该写怎样的博客</a>》一文中提到的一样，我不希望写的技术文章只是生搬其他博客的内容，没有自己的创新点。<strong>优秀的技术博客不是自己的笔记本而已</strong>。</p><p><a href="blog.ioshub.cn">iOSHub</a> 博客也不会只限制于写我自己的 iOS 开发知识。我也会不定时的翻译一些我觉得不错的外文文章，设计也好开发也好，我觉得和开发中的美有关的文章，我可能都会考虑翻译。</p><h2 id="MoSplash"><a href="#MoSplash" class="headerlink" title="MoSplash"></a>MoSplash</h2><p>我开始做独立开发者了。MoSplash 就是我的第一个作品。目前还在开发中。</p><p><img src="http://chanjh.b0.upaiyun.com/0027/MoSplash.png" alt=""></p><p>成为独立开发者这个想法一直在我心里回旋。高一时，我第一次接触编程，在那时候的诺基亚 5700 上编写了我的第一个个人 App，但那时候诺基亚已经没落，Android、iPhone 开始称霸世界。高三的时候，我开始关注到微信公众号和背后灵活的开发接口，于是编写了一个查成绩的校园公众号，仅运营半年粉丝量就超过了学校的在校人数（在校生五六千人，粉丝达八千）。</p><p>我喜欢做自己的作品。进入大学之后，iOS 开发成为我学习的方向。大一的时候我进入了 TopView 工作室，接手了几个 iOS 项目，完成了 iOS 开发入门。然而进入了 2017 年，喜欢做自己想做的事情的心灵又再次唤醒，希望能做出自己的产品。</p><p>上个月我参加了苹果公司的 iOS Club 冬令营，那里对创意的尊重和创造者的匠心氛围打动了我，也促使我加快进入 iOS 独立开发的行列。</p><p>MoSplash 还处于开发中。关于 MoSplash 的开发故事我会发布在 <a href="blog.ioshub.cn">iOSHub</a> 中。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这就是我最近在做和我想做的事情，希望在 ChanTalk、iOSHub 能和你有更多的互动。<br>联系我：<br>技术博客：<a href="https://ioshub.cn" target="_blank" rel="external">iOSHub</a><br>iOSHub 是我的技术博客，主要内容为我在 iOS 开发中发现和探索过程的记录。</p><p>个人博客：<a href="https://chanjh.com" target="_blank" rel="external">ChanTalk</a><br>知乎专栏：<a href="https://zhuanlan.zhihu.com/ChanTalk" target="_blank" rel="external">ChanTalk</a><br>ChanTalk 是我的个人博客，分享创意、记录思考。</p><p>微博：<a href="http://weibo.com/bj416" target="_blank" rel="external">陳某豪</a><br>微博上我会吐槽、分享一些短内容，欢迎关注。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 ChanTalk、iOSHub 和独立开发。&lt;/p&gt;
    
    </summary>
    
    
      <category term="独立开发, 技术" scheme="http://yoursite.com/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91-%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>软件开发的理与美——记 iOS Club 之行</title>
    <link href="http://yoursite.com/2017/02/24/0001/"/>
    <id>http://yoursite.com/2017/02/24/0001/</id>
    <published>2017-02-24T03:55:00.000Z</published>
    <updated>2017-03-13T08:58:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>真正伟大的人还会继续向前，直到找到问题的关键和深层次原因，然后再拿出一个优雅的、堪称完美的有效方案。– Steve Jobs  </p></blockquote> <a id="more"></a><h2 id="初识-iOS-Club"><a href="#初识-iOS-Club" class="headerlink" title="初识 iOS Club"></a>初识 iOS Club</h2><p>iOS Club 是苹果公司在东莞华南设计院举办的一个大学生 iOS 开发训练营，来自全国各地12所高校近百名学员参加了这次冬令营。</p><p>2 月 13 日，我们一行人从广州天环广场 Apple Store 乘车出发，前往东莞华南设计院。当现场听到苹果公司中国区教育拓展总监 Carrie Chen、苹果公司中国教育行业资深经理 Phoebe Chen 等的开场介绍时，我便意识到此次活动将充满乐趣和收获。</p><p><img src="http://chanjh.b0.upaiyun.com/0026/IMG_2790.jpg" alt=""></p><h2 id="「理」是工程师的主旋律"><a href="#「理」是工程师的主旋律" class="headerlink" title="「理」是工程师的主旋律"></a>「理」是工程师的主旋律</h2><p>这次参加 iOS Club 的学生大部分都是计算机专业的学生。似乎一开始大家到来 iOS Club 的目的都是想要来学习更多开发的知识和技巧。iOS Club 也为我们提供了多个围绕 iOS 开发的课程，包括 Robert Ma 老师的 iOS 自动化测试详解、同济大学朱宏明教授的 iOS Core Animation 讲解。</p><p><img src="http://chanjh.b0.upaiyun.com/0026/IMG_2695.jpg" alt=""><br>Robert Ma 老师讲解 iOS 开发自动化测试</p><p>自从学习 iOS 开发以来，这是我第一次现场接受 iOS 开发培训，而且还是来自 iOS 开发领域有多年耕耘的前辈，感觉到无比的荣幸，也收获了很多。</p><h2 id="「美」是工匠最出色的和弦"><a href="#「美」是工匠最出色的和弦" class="headerlink" title="「美」是工匠最出色的和弦"></a>「美」是工匠最出色的和弦</h2><p>真正的科技是要让你感受不到科技的存在。真正的科技，是让你的感受回归生活。缺乏美的创造就像螺丝拼凑起来的钢铁巨人，与人缺乏亲和。这次 iOS Club 最大的收获，是来自设计院乃至整个苹果公司追求美学和用户体验的洗礼。</p><p><img src="http://chanjh.b0.upaiyun.com/0026/wwdc17.png" alt=""><br> WWDC17 海报</p><p>什么是「美」？ Bruce Gao 在「iOS 软件开发进阶之交互体验设计」课程上有一个结论，他说人机交互要做到「明细、尊重、深度」三大原则。以用户为中心的思想去思考产品的设计，就像「瞬间之美」一书的核心思想：Don’t let me think,让软件的设计回归到用户体验上，才能构造出一个足够优雅的软件产品。</p><p><img src="http://chanjh.b0.upaiyun.com/0026/IMG_2712.jpg" alt=""><br> iOS 软件开发进阶之交互体验设计</p><p>怎么创造「美」？ 赵航老师给我们传授了一种全新的思维方式：「Design Thinking」，设计思维连接从灵感、构思到实施的整个过程，利用其以人为本、凝聚众人智慧的特点，将团队的力量集中创意本身中。「Design Thinking」中棉花糖的游戏让我感触良多。小组成员使用有限的细绳、透明胶、意大利面将棉花糖尽可能高的架起来。组员们就是运用设计思维模式，灵感构思到最后的实施，在短暂的五分钟完成了一件从未挑战过的事情。</p><p><img src="http://chanjh.b0.upaiyun.com/0026/IMG_2709.jpg" alt=""><br> Design Thinking</p><h2 id="最出色的开发者-≠-最成功的-Coder"><a href="#最出色的开发者-≠-最成功的-Coder" class="headerlink" title="最出色的开发者 ≠ 最成功的 Coder"></a>最出色的开发者 ≠ 最成功的 Coder</h2><p>大多数人想要改造这个世界，但却罕有人想改造自己。Airbnb Staff Engineer 朱赟的《论程序员的自我修养》一文，第一点便提出「程序员的素养，首先是技术、交流沟通、演讲、领导力、处理问题能力」。一个出色的开发者不一定就是成功的 Coder，培养一名程序员也不是 iOS Club 的最终目标。培养综合型人才，让开发者适应新潮流，不求同、多存异，是这次 iOS Club 之旅的收获之一。</p><p><img src="http://chanjh.b0.upaiyun.com/0026/IMG_2715.jpg" alt=""><br> 刘志明老师的 Storytelling Skill 课程</p><p>刘志明老师的 Stroytelling Skill 课程为我们传授了 App 开发之外的学问。程序员从代码层级上完成了一个 App，并不代表他的应用就能成功。分享产品故事、分享产品体验能让一个 App 引发用户的共鸣。也在同一天，Doris 老师的 Keynote 制作技巧课程里为我们提供了 Keynote 设计和演讲的实用技巧，帮助开发者走出纯粹的开发，成为一个演讲者。</p><p>一个只会敲打代码的程序员只能成为新时代下的蓝领工人，而富有表现力的开发者才能更加的立体。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>乔布斯回归苹果公司时，曾经做了一个简短却富有感染力的广告「Think Different」。现如今中国大学生都沉浸在「万众创新、大众创业」的双创氛围下，创业成为我们这一代人的摇滚。而这其中有多少创业创新者能停下脚步来思考用户、思考自己的故事和思考求异不苟同呢？</p><p>数日的 iOS Club 之旅，让我感觉 iOS Club 是一个还原大学生综合素质的训练营，在这里每一个开发者都有机会学习到来自 Apple 的理念和思想。愿 iOS Club 可以越办越好，走进更多 iOS 开发者、使用者中去。</p><p>iOS Club 我们来年再会。</p><p><img src="http://chanjh.b0.upaiyun.com/0026/IMG_2788.JPG" alt=""><br>  我和我的组员合照</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;真正伟大的人还会继续向前，直到找到问题的关键和深层次原因，然后再拿出一个优雅的、堪称完美的有效方案。– Steve Jobs  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS,Apple,开发者,培训" scheme="http://yoursite.com/tags/iOS-Apple-%E5%BC%80%E5%8F%91%E8%80%85-%E5%9F%B9%E8%AE%AD/"/>
    
  </entry>
  
  <entry>
    <title>程序员应该写怎样的博客</title>
    <link href="http://yoursite.com/2016/11/28/0000/"/>
    <id>http://yoursite.com/2016/11/28/0000/</id>
    <published>2016-11-28T06:55:00.000Z</published>
    <updated>2017-03-13T09:24:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://chanjh.com/" target="_blank" rel="external">ChanTalk</a> 是我自己的博客，一直以来我的信念都是「记录思考，分享创意」如此纯粹，虽然要求自己至少每个月更新两篇，但遇到事情比较多的时候，就真的没时间思考，更没时间更新博客。</p><p>恰逢完成了最近工作室的项目，想要静下心来写一写与开发相关的文章。然而似乎一直以来 ChanTalk 的内容都比较偏向产品和攻略，程序员的事情只写过那么一两篇。正因如此，我便困惑在「程序员应该怎么样写博客」这个问题上。</p><a id="more"></a><p>作为一名计算机专业的学生，身边也是离不开一票票的程序员。在大多数会写博客的程序员看来，就像是少年时候写作文「引经据典」的加分项一样，「写博客」就是自己以后找工作时候的加分项。在这种程序员眼里，写博客成为一种体力活，他们在文章里只分享「干货」，阐述某个工具、某些用法的机械性理解。但是他们并没有意识到，这类文章在 Google 一搜遍地都是，缺乏理解的搬砖，都是利用博客的幌子在耍流氓。</p><h2 id="程序员要写怎么样的博客"><a href="#程序员要写怎么样的博客" class="headerlink" title="程序员要写怎么样的博客"></a>程序员要写怎么样的博客</h2><p>程序员写干货应该分享比较「湿」的干货。什么叫比较「湿」的干货？一，程序员写干货，应该着眼更新鲜、更前沿的开发技巧和咨询上；二，程序员写干货，应该在更深的地带去挖掘开发中的乐趣，要把事情讲明白，不要总是有着一股欲言又止的暧昧。王巍老师的博客（<a href="https://onevcat.com/#blog" target="_blank" rel="external">OneV’s Den</a>）就是「湿货」的代表。在 WWDC 之后，王老师都会很及时地讲解 WWDC 上 iOS、macOS 等开发的更新，在博客中也能看到他在函数式链式编程的看法和实践。这就是很「湿」的干货，它是有价值并且值得被保存的。</p><p>程序员写博客不应该把眼光局限在开发的世界中。一些程序员在写文章还保留着在写代码时候的职业病和惯性，聊来聊去依然是代码和架构。程序员写文章也可以写的天真烂漫。我开始能够被称为「程序员」的时候，大概就是我开始关注池建强老师的时候。池老师的公众号叫做「<a href="http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=MjM5ODQ2MDIyMA==#wechat_webview_type=1&amp;wechat_redirect" target="_blank" rel="external">MacTalk</a>」，从名字上就能发现我受到不少他的影响。池老师的文章，从 Mac 的使用聊到程序员的职业生涯，从自己聊到朋友，从开发聊到未来，喜欢池老师的发散性思维，也是在池老师的影响下，我才知道了 Airbnb 的 <a href="http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=MzA4ODgwNjk1MQ==#wechat_webview_type=1&amp;wechat_redirect" target="_blank" rel="external">Angela</a> 老师，她从程序媛聊到工程师的成长，从代码能力聊到领导力。程序员写博客，不应该把博客当作自己技术能力的延伸，而应该让博客成为自己综合实力的发展。</p><p>Kevin（<a href="http://blog.zhowkev.in/" target="_blank" rel="external">Kevin 的 blog</a>）是一位我十分敬仰的 iOS 开发者。他不仅是一名开发者，也是生活的体验者、产品的审视者。看他的博客，也不是纯粹的技术能力的体现，更多的是他在开发和审视中的思考。正如他在对 Dash 的开源代码的文章透露出来的思想一样，我们程序员要尊重技术，但也要参透产品本质。</p><h2 id="所以我想说什么"><a href="#所以我想说什么" class="headerlink" title="所以我想说什么"></a>所以我想说什么</h2><p>记得我第一次和产品老总开完会，总结第一个 Demo 的改进点之后，那天晚上我重新比对需求和项目工程，当所有需求汇集在一起时，发现工程其实是要推倒重来。这个项目的第一阶段目标是完成一个演示版本，在月末的展会中展示，当时的我困惑在这个短期项目的需求和未来真正可上线的版本存在着很多不同点，困惑在如果要真正上线我可能也要重新做很多工作。如果死守技术，不去理解产品的目的与本质，那么可能会制造出更多没有价值的代码。</p><p>写这篇文章的时候，觉得标题起得有点大了，看似一个乳臭未干的毛孩趾高气昂地准备教训正在写博客的前辈们。我不否认存在即合理，不否定纯技术流对于像我一样在成长中的程序小猴子有着很多学习参考作用。但其实写这篇文章的目的，是为了告诉我自己想成为怎么样的开发者，我会为了什么发声，毕竟我有我自己的独木桥。</p><p>曾经和一个对机器学习感兴趣的同学聊天，我说虽然我们都是开发者，坐在相似的岗位打出相似的文字，却有着那么不一样的道路。他感概也曾想要往做产品的方向发展，可是最后却跟着内心慢慢地走到了研究机器学习的道路上。</p><p>是啊，一切唯心而已。</p><p><img src="http://chanjh.b0.upaiyun.com/0024/pic.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://chanjh.com/&quot;&gt;ChanTalk&lt;/a&gt; 是我自己的博客，一直以来我的信念都是「记录思考，分享创意」如此纯粹，虽然要求自己至少每个月更新两篇，但遇到事情比较多的时候，就真的没时间思考，更没时间更新博客。&lt;/p&gt;
&lt;p&gt;恰逢完成了最近工作室的项目，想要静下心来写一写与开发相关的文章。然而似乎一直以来 ChanTalk 的内容都比较偏向产品和攻略，程序员的事情只写过那么一两篇。正因如此，我便困惑在「程序员应该怎么样写博客」这个问题上。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Designing in color</title>
    <link href="http://yoursite.com/2016/08/10/0003/"/>
    <id>http://yoursite.com/2016/08/10/0003/</id>
    <published>2016-08-10T06:38:00.000Z</published>
    <updated>2017-03-15T05:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<a href="https://medium.freecodecamp.com/designing-in-color-abd358660a7b#.txxtxy2er" target="_blank" rel="external">Designing in color</a></p></blockquote><p><img src="https://cdn-images-1.medium.com/max/2000/1*swrEZXQYr_JS9tG5vP0hYw.png" alt=""></p><p>色彩是在设计之中有着强大的影响。它可以吸引你的眼球、唤起灵感、传递精神。为了让你了解到色彩的意义所在，一篇被广泛引用的文章——《色彩在市场销售中的影响》中，调查者发现在一些产品中，消费者做出的 90% 的快速决定可能仅仅是来自于产品的颜色。</p><a id="more"></a><p>有效地使用色彩在设计中是如此的重要。然而不同颜色之间的组合似乎一直是个难题。每个颜色都有属于它自己的含义，而颜色之间又能组合出无限的可能。</p><p>这篇文章的写作目的便是为了帮助你在设计上做出友好的颜色组合。试探更多颜色可以帮助你提高你对颜色的直觉。</p><blockquote><p>随着你使用越来越多的色彩，你会培养出一份搭配颜色的直觉。</p></blockquote><h1 id="选择一种配色"><a href="#选择一种配色" class="headerlink" title="选择一种配色"></a>选择一种配色</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*9yK9NSMPkTKydMBNcwlnmw.png" alt=""><br>▲Pretty fly for a color palette</p><p>有时候一个配色可以是瞬间灵感的结果。但大多数时候，配色来自于有条理的方法。</p><h2 id="认清动机"><a href="#认清动机" class="headerlink" title="认清动机"></a>认清动机</h2><p>在做任何事情之前，首先需要想清楚你设计的目的。<strong>好的设计来源于清晰的动机下调校出的配色</strong></p><p>问一下你自己以下几个问题：</p><ul><li>你想要通过设计传递什么信息？</li><li>你的设计的目的是什么？是为了传递信息还是为了说服别人？</li><li>你想要通过你的设计传递怎么样的情绪？</li></ul><p>你的设计的动机会成为你选择你的配色的指导。</p><h2 id="认清你的受众"><a href="#认清你的受众" class="headerlink" title="认清你的受众"></a>认清你的受众</h2><p><img src="https://cdn-images-1.medium.com/max/1600/1*JSq4dylCICTghEu2-oVC4Q.png" alt=""></p><p>不同人对颜色的感知不同。正如 Fairchild 所说，色彩是一种通过观察产生的物理现象。颜色影响着人们的个人偏好、文化背景以及生活经验。正因如此，为了了解人们会对你的设计作出怎样的反应，你必须认清你的受众。</p><p>一些颜色对广罗大众的产生的效应是相似的，而另外一些则非如此。绿色因为他是蔬菜的颜色，通常代表着自然。然而，像红色之类的颜色在不同的文化中却有不同的诠释。在西方世界里，红色是火焰、暴力、战争的象征，有时也会和爱、热心联系在一起。然而，在中国以及其他国家，红色代表着繁荣和幸福。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*EWoRBath30IwXlTE4IliOw.png" alt=""></p><p><strong>颜色代表着如此多样的意思，所以作为一个设计者，为你的受众匹配一个正确颜色类型显得尤为重要。</strong></p><p>在了解更多关于不同国家地区对颜色的意义之前，可以查阅：<a href="https://www.helpscout.net/blog/psychology-of-color/" target="_blank" rel="external">The Psychology of Color in Marketing and Branding</a> 以及 <a href="https://www.smashingmagazine.com/2010/01/color-theory-for-designers-part-1-the-meaning-of-color/" target="_blank" rel="external">The Meaning of Color</a>。</p><h2 id="回顾一下色彩理论"><a href="#回顾一下色彩理论" class="headerlink" title="回顾一下色彩理论"></a>回顾一下色彩理论</h2><p>了解一些色彩理论对选择配色有很大的帮助。<a href="https://en.wikipedia.org/wiki/Color_theory" target="_blank" rel="external">色彩理论</a>具有一套严谨的结构和切实可行的配色指导。它涵盖了从色轮到单独的颜色的意义。</p><p>推荐两本关于色彩理论的优秀书籍：Design School 的 《<a href="https://designschool.canva.com/color-theory/" target="_blank" rel="external">Color Theory</a>》以及 Hubspot 的《<a href="http://blog.hubspot.com/marketing/color-theory-design#sm.0000b2d5sjq45dd0qmr2bvxpdxttz" target="_blank" rel="external"> Color Theory 101</a>》。你可以在《<a href="http://www.fastcompany.com/3009317/why-is-facebook-blue-the-science-behind-colors-in-marketing" target="_blank" rel="external">Why Is Facebook Blue? The Science Behind Colors In Marketing</a>》中了解到更多关于色彩理论的应用。</p><h2 id="寻找灵感"><a href="#寻找灵感" class="headerlink" title="寻找灵感"></a>寻找灵感</h2><p>有时候会很难为了你的设计配出正确的色彩。优秀的艺术家也会「偷窃」，或者说，他们会从别人身上获取灵感。</p><p>大家获取配色灵感的渠道通常来自像 <a href="http://dribbble.com/" target="_blank" rel="external">Dribbble</a>、<a href="https://www.behance.net/" target="_blank" rel="external">Behance</a> 这样的网站。如果你想为一些特定的设计<br>风格寻找配色，例如 Material Design，可以在 <a href="https://www.materialui.co/colors" target="_blank" rel="external">MaterialUI</a> 中找、Flat Design 可以在 <a href="https://flatuicolors.com/" target="_blank" rel="external">FlatUIColors</a> 上找。</p><p><strong>这些网站很有用，但尝试着，在这些特定的媒介之外的地方寻找设计。</strong>如此一来，你有机会获得不同凡响又令人愉悦的配色。比如，你可以留意观察室内设计</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*OdeGb0Xk-rTK48O6y9oGvg.png" alt=""></p><p>如果你想要一些不一样的东西，可以在不同的文化背景里寻找灵感。比如，韩国的 MV 以他们丰富的色彩和夺人眼球的配色而出名。每一个框架都能成为灵感的来源。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*7nd9Fw5PakxA7DWytfMz-Q.png" alt=""></p><p>你用不着一定要飞到韩国去寻找灵感。它就在你生活的一点一滴中。当你下次出行的时候，停下脚步来欣赏你身边的色彩。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*1b12Qt0HEFr8ezQc7obDhw.png" alt=""></p><p>当你发现一些触发你的灵感的事物时，可以为它构造一种配色方案。你可以使用你的滴管工具在你喜欢的设计中选取一些配色然后为适应做出一些适当的调整。</p><h2 id="建立一个设计体系"><a href="#建立一个设计体系" class="headerlink" title="建立一个设计体系"></a>建立一个设计体系</h2><p>一个设计体系（Design system）有时也被称为风格导向（style guide），是一个概括所有基本你的设计中的基本元素的框架。其中囊括从按钮到排版的一切，思考着你需要使用什么类型的按钮、什么样子的导航栏（navigation bar）。</p><p>作为一些关于设计体系的例子，你可以仔细观察一下 <a href="https://www.lightningdesignsystem.com/design/overview/" target="_blank" rel="external">Salesforce</a> 的设计体系，也可以在<br><a href="https://designschool.canva.com/blog/50-meticulous-style-guides-every-startup-see-launching/" target="_blank" rel="external">50 Meticulous Style Guides Every Startup Should See Before Launching</a> 列表中查看更多。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*PjoC46xkLRyQR2BnZTkpAg.jpeg" alt="The design system of MashCreative"><br>▲    The design system of MashCreative</p><p>在选择一种配色前先建立一个设计体系，即使只是一个粗糙的草稿，对你的设计都会起到很大的帮助。这么做可以让你明白你的设计应该有什么元素以及应该用什么颜色搭配他们。</p><p>当选择了一种配色之后，应该坚持 KISS 的原则（即 Keep it simple，stupid）。越少的颜色越好。可以从以下部分开始建立一个设计体系：</p><ul><li>背景</li><li>主事物（Primary accent）</li><li>次事物（Secondary accent）</li><li>错误色（Error color）</li><li>正确色（Success color）</li></ul><p>主配色是你必须经常用在你的按钮和主事物上的颜色。在很多公司的设计里，它也是 logo 的颜色。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*0QNmagorcKgNG_mLDibQYA.png" alt=""></p><p>次配色一般用来与重要操作作为区分的颜色。例如，主要和次要的按钮。错误色以及正确色，比如比较普遍的红色和绿色，会用来表现状态。例如成功和错误的提示。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*PhT74LSWHk4__X5RseKq8Q.png" alt=""><br>▲Design states</p><h2 id="选择一种配色-1"><a href="#选择一种配色-1" class="headerlink" title="选择一种配色"></a>选择一种配色</h2><p>现在你有了创作的灵感和设计的草案，接着就要选择一种配色方案。</p><p>作为一种基本的配色，我习惯于将我的颜色一个个排开来，就像艺术家在调色板上做的那样。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ZRcWzTmUo3Ydz2R0-kLpFg.png" alt=""></p><p>现在你需要带着你的灵感并且为它们搭配出一种适宜的配色。越多越好。<strong>不要害怕尝试</strong>。</p><p>当你不断的缩小你的配色方案的选项是，回忆一下一开始你是如何定义你的设计目标和受众的。思考一下几个问题：</p><ul><li>哪些设计是<a href="https://www.smashingmagazine.com/2014/10/color-contrast-tips-and-tools-for-accessibility/" target="_blank" rel="external">必须的</a>？</li><li>哪些颜色让你眼前一亮并且立刻爱上他？</li><li>人们使用你的产品的时间是什么时候？是否需要一个日间和夜间的颜色设计？</li><li>你的设计想要传递怎样一种心理？有没有更好的配色能够传递这种感觉？</li></ul><p>就像我最后提出的这点，颜色在设计中会有不一样的规律。这也意味着每种颜色在你的设计中会有不一样的比重。比如你的背景色会比主色更经常的使用。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Fvk4qA0xpoFClIAlmg0nig.png" alt=""></p><p><strong>正因如此，创建一个由不同大小的形状组成，并且每个形状粗略的等于出现的频率和给出纸张上 颜色的平均表面积的一次性的设计，有时会是一种很棒的经历</strong></p><p>这里以 <a href="https://www.invisionapp.com/" target="_blank" rel="external">Invision’s</a> 的配色为例子：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*becutEEFQmvIWeLjBeKvBw.png" alt=""></p><p>用图形可以像这样描述：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*FAMOU47ynYQCEXL1izwXMw.png" alt=""></p><h2 id="应用配色"><a href="#应用配色" class="headerlink" title="应用配色"></a>应用配色</h2><p>为了让你更好的理解怎么在设计中应用颜色，我们来看一下 <a href="https://www.airbnb.com/" target="_blank" rel="external">Airbnb</a>。 Airbnb 的主色是 Rausch ，是以起源的公司所在街道命名的颜色。同时使用 Kazan 作为次颜色以及两种灰色作为背景色。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Qc0eyQgET7vnnfWWG1SgJw.png" alt=""><br>▲<a href="http://airbnb.design/" target="_blank" rel="external">Airbnb’s brand colors</a></p><p>在大多数网页里，Airbnb 会用模糊的灰色作为背景色。你可以发现他们用 Rausch 作为主色来强调一些重要的操作，例如请求预定。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Vg5Oo5i5K_QDkL3uCwheSA.png" alt=""></p><p>Kazan 是一种青绿色，用来引起你的注意力。请留意它是如何衬托主色调的。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*9zYNQp_396HxbUEDFOnuCw.png" alt=""></p><p>而对于错误色，Airbnb 使用了一种明亮的红色，可以和 Rausch 呼应。这种红色可以起到强调作用，瞬间抓取你的眼球，让你意识到系统的通知。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*-brdYdBfSMzMdTz4N0JHOg.png" alt=""></p><p>从没有任何配色开始，要留意排版和元素之间的放置。当你满意之后，可以开始在设计中应用你的配色。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*Sh16esT2Lh46xrP8E_tkxw.png" alt=""><br>▲<a href="https://dribbble.com/shots/2760945-Store-Sale/attachments/562155" target="_blank" rel="external">Start off without color and slowly add from there</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>颜色意味着不断的试验。如果你想要变得更好运用色彩，唯一的办法就是不断的练习。把颜色当做一种添加剂。如果你已经有产品的排版和功能，那你可以尽情发挥你的想象去试验不同的配色。</p><p>学会如何搭配颜色对设计师来说是十分重要的一件事情。当你越来越熟悉的选择适当的颜色之后，你甚至能在接触产品之前就想象出他的配色来。</p><p>我很愿意去了解你在工作中是如何和颜色打交道的。你的步骤是什么？来 <a href="https://twitter.com/JonathanZWhite" target="_blank" rel="external">Tweet</a> 上和我留言吧！</p><p>PS：如果你喜欢本文，你的点赞和分享将会带来更多的意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;https://medium.freecodecamp.com/designing-in-color-abd358660a7b#.txxtxy2er&quot;&gt;Designing in color&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*swrEZXQYr_JS9tG5vP0hYw.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;色彩是在设计之中有着强大的影响。它可以吸引你的眼球、唤起灵感、传递精神。为了让你了解到色彩的意义所在，一篇被广泛引用的文章——《色彩在市场销售中的影响》中，调查者发现在一些产品中，消费者做出的 90% 的快速决定可能仅仅是来自于产品的颜色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Design, 翻译" scheme="http://yoursite.com/tags/Design-%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>自动布局（Auto Layout）介绍</title>
    <link href="http://yoursite.com/2016/07/23/0002/"/>
    <id>http://yoursite.com/2016/07/23/0002/</id>
    <published>2016-07-23T14:00:00.000Z</published>
    <updated>2017-03-15T05:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文来自：<a href="http://www.appcoda.com/introduction-auto-layout/" target="_blank" rel="external">Introduction to Auto Layout</a></p></blockquote><p>编者按：如果你已经下载过 Xcode 6 Beta 并且已经在那上面溜过一圈，有一样相信你不会没发现的改变：Interface Builder（界面构建）的那些变化。默认的 View Controller 更加宽阔，看起来并不像是 iPhone5 的大小。当你放置一个按钮在界面中间然后运行程序，你会发现它看起来有点糟糕——按钮并没有正确地显示在界面中央。</p><a id="more"></a><p>所以这其中有什么出错了吗？你又该怎么使按钮布局正确？这个答案就是自动布局（Auto Layout）。Auto Layout 是一个根据限制（constraint-based）来布局的方法。其允许开发者创建一个自适应的界面来做到合适地在不同屏幕大小和旋转方向之间调整。我们很少在我们的教程之中谈到 Auto Layout。一个初学者觉得它很难学因而避免去使用它。从 Xcode 6 开始，你应该学习并爱上 Auto Layout。苹果公司将在这个这个秋天推出 4.7 英寸和 5.5 英寸的 iPhone 6。如果没有 Auto Layout，你可能非常难开发出一款适应多种不同屏幕大小的 App。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/07/auto-layout-featured.png" alt=""></p><p>所以从本周起，我们将会推出一系列关于 Auto Layout 的文章。我们将从基础开始讲起。</p><p>下面带来 Ziad 为我们讲解的 Auto Layout 介绍。</p><p>我明白现在有挺多开发者不喜欢 Auto Layout，可能因为它相当的新颖而幼稚或者说它一开始难以上手。但请相信我，一旦你熟悉去使用它，它将成为你编写 app 时不可或缺的最佳工具。在这篇教程中，我将给你带来最简洁易懂的 Auto Layout 上手介绍。</p><h2 id="Why-Auto-Layout？"><a href="#Why-Auto-Layout？" class="headerlink" title="Why Auto Layout？"></a>Why Auto Layout？</h2><p>Auto Layout 是一种通过定义因素间关系、帮助开发者创建用户界面（User Interface）的方法。它提供了一种灵活并强大的方法来描述视图（view）和控件（UI controls)之间如何彼此联系。通过使用 Auto Layout，你可以运用种类多样的自定义，十分友好地控制布局，做出完美的界面。</p><p>Auto Layout 是一个非常棒的工具，它做到了早期科技从来没想过的的事情。从处理创建视图间的相互关系的表现（原文：edge case)来看，Auto Layout 表现出巨大的能力。初次之外，Auto Layout 还和苹果的多数令人激动的 API 和谐兼容，包括动画（animations）、动作效果（motion effects）和子画面（sprites）。</p><p>Ok，现在我将示范一下 Auto Layout，希望能帮助你明白为什么 Auto Layout 如此重要。在故事板（storyboard）中，放置一个按钮（button）在视图的中央。在虚拟机上用 iPhone Retina（3.5 英寸）和 iPhone Retina（4 英寸）运行程序。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/07/auto-layout-press-me-center.jpg" alt=""></p><p>你会得到以上的运行结果。可以看到，在 3.5 英寸的 iPhone 上运行的程序中按钮并没有正确的放置在中间。</p><p>这其中出了什么问题？</p><p>如果没有 Auto Layout，我们放置在 storyboard 上的 UI controls（如 button）会被固定在位置上。换句话说，我们「强制编写」了控件的 frame origin。例如，「Press Me」这个按钮的 frame origin 会被设置为（104，255）。因此，无论是在 3.5 还是 4 英寸的 iPhone 上，iOS 都会将控件绘制在如上所述的位置上。这就能解释为什么「Press Me」按钮不能在 3.5 英寸上正确显示，因为屏幕的高度是不同的。</p><h2 id="在-Interface-Builder-中如何使用-Auto-Layout"><a href="#在-Interface-Builder-中如何使用-Auto-Layout" class="headerlink" title="在 Interface Builder 中如何使用 Auto Layout"></a>在 Interface Builder 中如何使用 Auto Layout</h2><p>在解决上述例子的问题之前，我们先简单的了解一下 Interface Builder，理解 Auto Layout 是怎么被应用的。</p><p>首先新建一个工程（project），选择  Single View Application iOS app view。在 project 选项中，选择 Device 为 iPhone，保存 project，打开 storyboard。能够在右下角看到一个菜单。这些按钮便关系到你的 Auto Layout。你可以使用 Align（对齐）、Resizing（尺寸）、Pin（固定）、以及 Issues（事件）。</p><ul><li>Align：创建对齐约束，例如将两个视图左对齐</li><li>Pin：创建控件约束，例如规定 UI control 的宽度</li><li>Issues：解决对齐错误</li><li>Resizing：说明尺寸如何影响约束</li></ul><p><img src="http://www.appcoda.com/wp-content/uploads/2014/07/auto-layout-control.png" alt=""></p><p>除了右下角的菜单，苹果还制定了一个一种让开发者灵活的创建 Auto Layout 的方式：Control 键。你可以按住键盘上的 Control 键后点击鼠标，从一个视图拉到另一个上，这样便能创建两者的约束，此时你松开鼠标，就会出现一个可选的约束列表。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/07/auto-layout-control-drag.gif" alt=""></p><p>一旦你在一个 view 中创建了约束，在它上面将会出现一个橙色或者蓝色的约束线。橙色线代表存在不充足条件的约束，你需要去解决它。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/05/Screen-Shot-2014-06-01-at-8.20.01-PM.png" alt=""></p><p>蓝色线则说明你的布局可以正确的显示，并不存在歧义。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/05/Screen-Shot-2014-06-01-at-8.20.15-PM.png" alt=""></p><p>有时你创建一个约束之后，界面框上会有警告提醒。红色的箭头也说明布局有冲突或者歧义。点击提醒，可以看到一个错误的列表。这些问题按照一个个场景展示出来。典型的错误包括缺乏约束（missing constraints）、有歧义的约束（conflicting constraints）以及视图位置出错（misplaced views）。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/05/Screen-Shot-2014-06-13-at-1.41.28-AM.png" alt=""></p><p>在 Size Inspector 中，你可以看到一些被添加过的约束，在“Constraints”的选项卡内。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/05/Screen-Shot-2014-06-01-at-8.31.11-PM.png" alt=""></p><p>除了 size inspector 视图，这些约束也会在 Interface Builder Outline 下相应的出现。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/05/Screen-Shot-2014-06-01-at-8.38.52-PM.png" alt=""></p><h2 id="Auto-Layout-例子：居中按钮或图片"><a href="#Auto-Layout-例子：居中按钮或图片" class="headerlink" title="Auto Layout 例子：居中按钮或图片"></a>Auto Layout 例子：居中按钮或图片</h2><p>至此你应该对 Auto Layout 和如何设置约束有了一个比较基础的了解。现在重新回到一开始的例子，看看怎么居中一个按钮或者图片。</p><p>正如前面所说的，Auto Layout 是一个根据限制（constraint-based）来布局的方法。基于此，开发者可以创建一个自适应的界面来做到合适地在不同屏幕大小和旋转方向之间调整。好吧，听起来很牛逼，但「根据限制布局」究竟代表什么？我尝试用更平素的语言描述吧。回到我们的「Press Me」按钮，你怎么描述它的位置？可能会是：</p><p>不管屏幕尺寸如何，这个按钮都应该在垂直和水平坐标的中心。</p><p>现在你已经定义了两个约束（垂直居中和水平居中），这两个约束反映出标签和界面的布局。Auto Layout 的意义便在于约束。然而，约束是用精确的形式表现的。例如，如果你定义了一个按钮的位置，你可以会这么说：按钮的左边跟容器的左边应该相距 30 点。这等价于：button.left = (container.left + 30)</p><p>好了，这样便足以了解 Auto Layout 的概念了。</p><p>现在我们来看看怎么在屏幕中居中一个图片。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/05/Screen-Shot-2014-06-14-at-12.31.17-PM.png" alt=""></p><p>假定你已经添加了一个 image view 并防止在视图中间，第一步要对它的宽和高做出约束。这里我将讲解怎么用 Auto Layout 的菜单。选择 image view 然后点击 Pin，选择 height 和 width，然后点击「Add 2 constraints」。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/07/auto-layout-size-constraints.jpg" alt=""></p><p>你可能发现到有红色警示出现在界面边框，这是提醒我们 image view 中存在约束问题。Xcode 可以帮助我们解决它们。点击红色警示，根据红色的指示最后点击「Add missing constraints」。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/05/Screen-Shot-2014-06-14-at-11.20.44-AM.png" alt=""></p><p>好了，我们已经设置好约束。接着我们将设置一个居中的约束，这样即使用户旋转屏幕也能正常显示。先选择 image view 然后点击 Auto Layout 菜单的 Alignment 图标。在弹出的菜单中，选择「Vertical center in container」和「Horizontal center in container」选项，紧接着点击「Add Constraints」。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/05/Screen-Shot-2014-06-13-at-1.04.19-PM.png" alt=""></p><p>现在你可以测试你的 app 了。编译并启动它，尝试在横屏竖屏中切换，可以看到 image view 始终保持在中间。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/07/auto-layout-example-image.jpg" alt=""></p><p>我们已经示范了怎么使用 Auto Layout 菜单来添加约束。你也可以用 Control 键实现一样的功能。下面来讲解它是怎么实现的。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/07/auto-layout-centre-button.gif" alt=""></p><h2 id="Auto-Layout-例子：登录按钮"><a href="#Auto-Layout-例子：登录按钮" class="headerlink" title="Auto Layout 例子：登录按钮"></a>Auto Layout 例子：登录按钮</h2><p>众所周知，iPhone 5 和 iPhone 4 是不一样尺寸的。这就需要一些微调来适应不同屏幕大小。思考一下下面的登录界面，登录的按钮被放置在视图的底部。如果你没有使用 Auto Layout，在 3.5 英寸的设备上将不会显示到登录按钮。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/07/auto-layout-login-compare.jpg" alt=""></p><p>那么要怎么解决这个问题？要解决这个问题，我们又回到之前的话题上，我们需要建立一个保证它放置在屏幕底部的约束。最重要的是，它的宽度也要随着旋转而改变。</p><p>首先我们需要为按钮高度添加一个大小的约束。只添加高度的约束即可，宽度则根据设备的方向改变。按住 Control 键鼠标点击按钮然后垂直的拖动一下，选择 height，通过添加这条约束解决掉 Interface Builder Outline 提示的歧义。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/05/Screen-Shot-2014-06-14-at-1.00.07-PM.png" alt=""></p><p>为了保证按钮在设备处于不同方向的时候能与边缘保持相同的距离，我们需要添加另一个约束。按住 Control 键从按钮拖动到父视图的左边缘，选择「leading space to the container」。重复相同步骤到父视图的右边缘，选择「trailing space to the container」。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/07/auto-layout-login-trailing.gif" alt=""></p><p>最后一步需要添加一个让按钮保持在屏幕底部的约束。按住 Control 键从按钮拖动到它的父视图底部，选择「bottom space to bottom layout」。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/05/Screen-Shot-2014-06-14-at-1.02.02-PM.png" alt=""></p><p>好了，现在不同设备上运行你的 app。多亏了 Auto Layout，登录的按钮可以正常的在 3.5 英寸的 iPhone 上显示。当设备旋转的时候，按钮也会相应的拉长。</p><p><img src="http://www.appcoda.com/wp-content/uploads/2014/07/auto-layout-login-landscape.jpg" alt=""></p><h1 id="what’s-Coming-Next"><a href="#what’s-Coming-Next" class="headerlink" title="what’s Coming Next"></a>what’s Coming Next</h1><p>在这次教程中，我们介绍了使用 Interface Builder 的 Auto Layout 的基础。希望通过这次教程和例子能让你开始喜欢上 Auto Layout 。一旦你掌握了 Auto layout 的基础，它将表现出十分强大的实力。你可以创建自适应的 UI 以适应不同的屏幕大小。在进阶的教程中，我们将举出更多 Auto Layout 的例子，向你介绍怎么使用有规划的使用 Auto Layout。</p><p>你可以在这里下载 Xcode</p><p>如果你有什么想法或者建议，可以在下面和我留言分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文来自：&lt;a href=&quot;http://www.appcoda.com/introduction-auto-layout/&quot;&gt;Introduction to Auto Layout&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编者按：如果你已经下载过 Xcode 6 Beta 并且已经在那上面溜过一圈，有一样相信你不会没发现的改变：Interface Builder（界面构建）的那些变化。默认的 View Controller 更加宽阔，看起来并不像是 iPhone5 的大小。当你放置一个按钮在界面中间然后运行程序，你会发现它看起来有点糟糕——按钮并没有正确地显示在界面中央。&lt;/p&gt;
    
    </summary>
    
    
      <category term="APP, 翻译" scheme="http://yoursite.com/tags/APP-%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
