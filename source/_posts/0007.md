---
date: 2017-08-06 18:24
status: public
title: MoSplash 技术开源：iOS 文件下载器是怎么实现的（一）
tags: MoSplash, 教程, iOS, 技术
---

7 月份 MoSplash 升级到了 2.0 的版本，这个版本最大的更新是优化了整个 App 的下载体验。从产品上来看，MoSplash 下载更加稳定、支持断点续传、支持后台下载、支持暂停取消等。从代码来看，这些功能都得益于 MoSplash 在 2.0 版本封装了一个文件下载层和图片操作管理器，解耦了这部分逻辑后，体验得到提升。今天来讲讲怎么封装文件下载器。

<!--more-->

# 框架选择
封装文件下载器可以选择苹果的 NSURLConnection 或者 NSURLSession，或选择第三方框架 AFNetwork 等。

NSURLConnection 是 iOS9之前的网络库，iOS9 之后已经被弃用，如果你的应用还需要支持 iOS9 以下的版本的话， 应该使用 NSURLConnection 或旧版本的 AFNetwork。

AFNetwork 3.0 实际上是对 NSURLSession 的封装。而且在文件下载方面的封装十分简单粗暴。如果你的项目的网络库都是基于 AFNetwork 封装的，那么文件下载器也可以考虑使用  AFNetwork。

MoSplash 是基于 NSURLSession 封装的文件下载器。本文也将以 NSURLSession 为例，讲解封装 FileDownloader。

# 需求分析

动手敲代码之前，我们先需要思考一个文件下载器需要哪些「功能」，换句话说，就是 FileDownloader 在接口文件需要暴露哪些 API。下面是常见的属性和接口：

```
* Method：
	* start
	* stop
	* continue
* Property
	* isDownloading:BOOL
	* downloadID:NSString
* Callback
	* downloadFinish
	* downloadError
	* progress
```

以上三部分可以对应接口中的方法、属性和 Delegate。这就是一个 FileDownloader 的接口。一个 FileDownloader 就是一个下载任务，在有些应用里，下载任务可能不止一个，需要有多个下载器共同来完成，这就需要在 Downloader 之上封装一层 DownloadManager。同样的，分析它的属性和接口如下：

```
* Method：
	* shareManager
	* add
	* stop (all or someone)
	* continue(all or someone)
	* fetch
* Property
	* taskCount:NSUInteger
	* taskArray:NSArray
* Callback
	* downloadFinish
	* downloadError
	* progress
```

Manager 将在《MoSplash 技术开源：iOS 文件下载器是怎么实现的（二）》中讲解。

# FileDownloader 实现

一个下载器可以分成这样几部分：操作方法（增加任务、暂停、继续）、NSURLSession 回调（下载完成、下载进度）、下载器 Delegate 回调（下载完成、下载进度）

## 操作方法

使用接口方法新建一个下载器：

```

@interface JHDownloader()<NSURLSessionDelegate>

@property (nonatomic, strong) NSURLSessionDownloadTask *downloadTask;
@property (nonatomic, strong) NSURLSession *backgroundURLSession;

@end

+ (instancetype)downloadWithRequest:(NSURLRequest *)request andDelegate:(id <JHDownloadDelegate>)target{
    JHDownloader *downloader = [[JHDownloader alloc]init];
    downloader.downloadID = request.URL.absoluteString;
    downloader.downloadDelegate = target;
    downloader.downloadTask = [downloader.backgroundURLSession downloadTaskWithRequest:request];
    [downloader.downloadTask resume];
    downloader.isDownloading = YES;
    return downloader;
}


#pragma mark -- getter and setter
- (NSURLSession *)backgroundURLSession {
    if(!_backgroundURLSession){
        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:[NSString stringWithFormat:@"%@",_downloadID]];
        _backgroundURLSession = [NSURLSession sessionWithConfiguration:sessionConfig
                                                delegate:self
                                           delegateQueue:[NSOperationQueue mainQueue]];
    }
    return _backgroundURLSession;
}
```

此处，JHDownloadDelegate 是下载器下载完成和下载进度的回调。如果是单一任务，那么可以设置 delegate 为 ViewController。如果 App 内有多个任务，可以设置 delegate 为 DownloadManger，然后在 Manager 内将信息传过去。

backgroundURLSession 的 downloadTaskWithRequest 方法可以生成一个 NSURLSessionDownloadTask， 使用 `[downloader.downloadTask resume]` 则可以开始任务。

任务的暂停和下载接口实现就比较简单了。

```
- (void)continueDownload{
    [self.downloadTask resume];
    self.isDownloading = YES;
}

- (void)stopDownload{
    [self.downloadTask suspend];
    self.isDownloading = NO;
}
```

## NSURLSession 回调

NSURLSession 的 Getter 里，设置任务 delegate 的为当前的下载器，在 Downloader 里实现 NSURLSessionDelegate 的两个方法：

```
/*
 当一个下载task任务完成以后，这个方法会被调用。我们可以在这里移动或者复制download的数据
 */
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location{

}

/*
 获取下载进度
 */
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite{

}
```

这两个方法比较容易理解。获取下载进度方法中，每个 int64_t 的参数分别代表：已写入磁盘的数据大小、已下载数据大小、文件总大小，可以用这些数据来计算下载完成度。

## 下载器 Delegate 回调

JHDownloadDelegate 里有三个可选回调：

```
@class JHDownloader;
@protocol JHDownloadDelegate <NSObject>
@optional
-(void)finishDownloadWithResponseData:(NSData *)responseData andDownloader:(JHDownloader *)downloader;

-(void)downloadingWithProgress:(float)progress andDownloader:(JHDownloader *)downloader;
@end
```

分别写到实现文件中去：

```
/*
 当一个下载task任务完成以后，这个方法会被调用。我们可以在这里移动或者复制download的数据
 */
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location{
    NSData *data = [NSData dataWithContentsOfURL:location];
    // 传递已经下载的数据用于保存
    if([self.downloadDelegate respondsToSelector:@selector(finishDownloadWithResponseData: andDownloader:)])
    {
        [self.downloadDelegate finishDownloadWithResponseData:data andDownloader:self];
    }
    self.isDownloading = NO;
}

/*
 获取下载进度
 */
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite{
    if([self.downloadDelegate respondsToSelector:@selector(downloadingWithProgress:andDownloader:)])
    {
        [self.downloadDelegate downloadingWithProgress:((float)totalBytesWritten/(float)totalBytesExpectedToWrite) andDownloader:self];
    }
}

/**
 * 下载失败
 */
- (void)URLSession:(NSURLSession *)session didBecomeInvalidWithError:(nullable NSError *)error
{
    if([self.downloadDelegate respondsToSelector:@selector(finishWithError:)])
    {
        [self.downloadDelegate finishWithError:error];
    }
}
```


至此，一个文件下载器就完成了封装。《[MoSplash 技术开源：iOS 文件下载器是怎么实现的（二）](http://blog.ioshub.cn/2017/08/06/0008/)》将介绍封装 DownloadManager。