---
date: 2017-10-30 18:40
status: public
title: iOS 中「数据」的流动：从 JSON 到 MVVM
tags: iOS, 开发, 基础
---

本文希望从『网络请求』这个常见的数据诞生地开始，广度的讲解 iOS 中常见的数据流动的知识。为了保证篇幅，一些入门的知识点不做扩展，每个标题下都有对应知识点，可以自行搜索学习。

* 目录：
	* JSON 转字典那点事儿（网络数据解析）
	* 字典到 Model 发生了什么事儿（OC Runtime）
	* Model 的保存这件事儿（iOS 持久层方案）
	* 数据层的设计探讨 （架构与设计模式）

<!--more-->

![](http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0012/QQ20171030-185021@2x.png)

## 0x00 JSON 转字典那点事儿

* 知识点：网络请求、HTTP 协议、NSJSONSerialization 使用

先看一下这段代码：

``` Objective-C
NSURL *url = [NSURL URLWithString:@""];

NSURLSession *session = [NSURLSession sharedSession];
NSURLSessionTask *task = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {

    NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];
    NSLog(@"%@", dic);
    
}];

[task resume];
```

这是一段简单的 NSURLSession 网络请求的 OC 代码。这里的关注点在 completionHandler 的 block 里。Handler 里返回了两个关键的参数：data 和 response。这里就需要一些 HTTP 协议的知识。

![](http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0012/QQ20171030-184732@2x.png)

一个 HTTP 请求其实包含了请求头和请求题。在这里，上面是 Head（响应头），下面是 Body（响应体），分别对应 Block 里的 Response 和 Data。

在 block 里，response 表示为一个 NSURLResponse 对象，通过打印就能清楚看明白它的结构。而 Data 是一个 NSData 对象，应该怎么理解呢？

这里要用 HTTP 在 TCP/IP 中传输的知识了。

简单讲就是在计算机网络里，数据被二进制化（序列化）、分包等操作后，在网络里传输。这个 data 就是一个序列化的结果（可以通过断点看到）。而我们怎么利用这个结果呢？

如果是 JSON，那么使用 NSJSONSerialization 的 JSONObjectWithData 方法可以得到 OC 对象（id 对象），此时根据 JSON 格式的不同，可以解析为 dictionary 或者 array。除了 NSJSONSerialization，也有其他的第三方库可以使用，它们可以处理更多 JSON 可能出现的情况。

对于 XML 可以用 NSXMLParser 解析。如果是其他数据（比如图片）可以用他们对应的构造器实现。

## 0x01 字典到 Model 发生了什么事儿

* 知识点：Model 层的封装、Runtime

### 常规的字典转 Model

其实这个过程就是常说的「字典转对象」的过程。这个过程其实不难，入门的话也很容易理解，但是要做到能够把代码写得足够优雅，就要了解多一些知识才行了。我们先来看一下，入门级别的「字典转对象」是怎么做的。定义一个 Model 有下列 property：

```Objective-C
@interface PhotoModel
@property (nonatomic, copy) NSString *link;
@end
```

这是一个 PhotoModel，有一个对应链接的属性。当我们从网络获得 data，解析为字典之后，想要转为 Model 时，可以在 PhotoModel 里定义 `initWithDic ` 方法，就能在实现里转化：

```Objective-C
-(instancetype)initWithDic:(NSDictionary *)dic{
    self = [super init];
    if(self){
        _link = dic[@"link"];
	  }
}
```

嗯，这样就完成了 JSON 转 Model 的过程。

这种方法本身没毛病，只是代码十分简陋。想象一下，当我们的模型拥有大量的属性时候，是不是需要复制粘贴大量的属性和键值对？可能维护一个 `init` 方法而已不足以带来麻烦，那如果你的 model 需要 Archive 呢？

我们知道，在 iOS Foundation 里支持一种数据保存方式叫 Archive（中文可以翻译为归档）。需要 Archive 的 Model 需要遵循 `NSCoding` 并实现 `-(void)encodeWithCoder:(NSCoder *)aCoder` 和 `-(id)initWithCoder:(NSCoder *)aDecoder` 方法

```Objective-C
-(void)encodeWithCoder:(NSCoder *)aCoder{
    [aCoder encodeObject:self.link forKey:@"link"];
}
-(id)initWithCoder:(NSCoder *)aDecoder{
    self = [super init];
    if (self) {
        self.link = [aDecoder decodeObjectForKey:@"link"];
	  }
}
``` 

这样你知道麻烦在哪了吧：你将维护之前三倍的代码！所以，字典转 Model 需要更科学的方法。

### OC 的 Runtime 特性

Objective-C 是一门动态绑定的语言。这句话相信我们在入门 iOS 的时候就已经听说，但是并不能理解它的含义。

我们熟悉的 C 语言使用的「静态绑定」，也就是说，在编译期就能决定运行时所应调用的函数。

``` C
void funcA(){
}
void funcB(){
}

void funcMain(int type){
	if(type == 0){
		funcA()
	}
	else{
		funcB()
	}
}
```

如果换成这个：

``` C
void funcA(){
}
void funcB(){
}

void funcMain(int type){
	void (*func)();
	if(type == 0){
		func = funcA;
	}
	else{
		func = funcB;
	}
	func();
}
```

那就需要用到动态绑定了。而 OC 就是一门动态语言，所要调用的函数直到运行期才确定。依靠强大的 Runtime 来实现这个功能。

利用 OC 的动态绑定的特性，我们可以在运行时观察 Model 的属性，甚至做到属性值的修改。下面以 Model 的封装来举例说明这个特性。同时，为了简单理解，只使用了继承的模式来实现 Model 封装。

我们的思路是，在程序运行时，使用代码枚举出 model 的属性，将属性名转化为 NSString 变量，那样就可以和字典的键（Key）对应上去了！思路是不是很简单。

首先需要引入 OC 的 runtime 框架 `#import <objc/runtime.h>` 。接着需要获取类的 Property，这里要用 `class_copyPropertyList(Class _Nullable cls, unsigned int * _Nullable outCount)` 的函数，它返回的是一个经过封装的 `objc_property_t` 指针，我们先认为它是一个类数组吧。

然后我们开始遍历数组，对每个 property  使用 `property_getName()` 函数获取它的属性名，这是一个 `const char` 类型的变量，只要用 UTF8 编码后，就是一个 NSString 对象了！

如果使用 KVC 的特性，可以对 model 使用 `[self setValue:[aDecoder decodeObjectForKey:nameStr] forKey:nameStr];` 设定属性的值。

对应的 `- (instancetype)initWithCoder:(NSCoder *)aDecoder` 和 `- (void)encodeWithCoder:(NSCoder *)aCoder` 如下：

```Objective-C
#import "JHBaseModel.h"
#import <objc/runtime.h>
@implementation JHBaseModel
- (instancetype)initWithCoder:(NSCoder *)aDecoder{
    self = [super init];
    
    unsigned int propertyCount = 0;
    objc_property_t * properties = class_copyPropertyList([self class], &propertyCount);
    
    for (unsigned int i = 0; i < propertyCount; ++i) {
        objc_property_t property = properties[i];
        const char * name = property_getName(property);
        
        NSString *nameStr = [NSString stringWithUTF8String:name];
        [self setValue:[aDecoder decodeObjectForKey:nameStr] forKey:nameStr];
    }
    if (properties){
        free(properties);
    }
    return self;
}
- (void)encodeWithCoder:(NSCoder *)aCoder{
    
    unsigned int propertyCount = 0;
    objc_property_t * properties = class_copyPropertyList([self class], &propertyCount);
    
    for (unsigned int i = 0; i < propertyCount; ++i) {
        objc_property_t property = properties[i];
        const char * name = property_getName(property);
        
        NSString *nameStr = [NSString stringWithUTF8String:name];
        [aCoder encodeObject:[self valueForKey:nameStr] forKey:nameStr];
    }
    if (properties){
        free(properties);
    }
}
```

这样，我们只要将 Model 继承于 JHBaseModel，就能不必再一次次地去实现两个 `NSCoding` 协议里的方法了。

那有朋友问，还是没解决 `-(instancetype)initWithDic:(NSDictionary *)dic` 的方法嘛。其实如果你的服务器返回的 JSON 字段是和 Model 属性名对应的，那用上面 `- (instancetype)initWithCoder:(NSCoder *)aDecoder` 的变形就能完成需求。

不过，有时候 JSON 的字段并不符合 OC 的命名习惯甚至直接不能那么命名（比如 id 字段），我们就必须手动维护一张字段解析的表。这类的做法比如著名的库：Mantle 

### 常见的字典转 Model 方法

* Mantle：使用继承和协议的方法
* MJExtension：使用类扩展的方法
* 自己封装 BaseModel 类，使用 Protocol 和继承的方法，实现字典转 Model

## 0x02 Model 的保存这件事儿

* 知识点：iOS 的数据持久化

到目前为止，我们的数据都只是以各个 OC 的『对象』形式存在于内存中。我们的应用需要把数据保存到硬盘里，来应付多种场景。常见的缓存保存方式：

* 数据库：大量数据。主要用于商品列表、聊天记录之类
* 文件：图片、音频、视频
* 内存：使用频率非常高的数据

在 iOS 里，保存方法可以有：

* Archive

对于需要归档的对象，需要遵循 NSCoding 协议，实现 `encodingWithCoder:(NSCoder *)aCoder` 和 `initWithCoder:(NSCoder *)aDecoder` 方法

归档时，使用 NSKeyedArchiver  保存数据。取出数据时，用 NSKeyedUnarchiver

这种方法，把数据归档保存到了硬盘中（可以在路径里找到 .archive 文件）。

我们的框架 PINCache 也用了 Archive 的方式缓存数据，只不过他的接口更友好。

* SQLite

SQLite 是移动端的轻量级数据库解决方案，它可以同时在多平台上运行。接下来我们要讲到的 CoreData 和 FMDB，都是基于 SQLite。

* Core Data

Archive 只能重写整个文件。Core Data 可以只读取已存对象中的一小部分。当模型对象的数量较少时，使用 Archive。而 Core Data 的增量存取、增量更新数据机制，可以胜任大量数据处理。

Core Data 可以将 OC 对象转化成数据，并将这些数据保存到 SQLite 数据库文件中。但是 Core Data 只能保存有限的几种数据类型（不能保存 UIImage 对象）。

Core Data 的实际上是 SQLite 的一个面向对象封装。

* FMDB

FMDB 的封装更靠近关系型存储。更多的保留了数据库本身的特性。

* 第三方库：Realm

Realm 是一个跨平台的数据库，它的 API 设计比 Core Data 优雅，也更加易懂。

网上有很多关于 Realm、FMDB、Core Data 的讨论，孰优孰劣还要听君定夺。

* 其他：WCDB、FireBase

## 0x03 数据层的设计探讨

* 知识点：架构与设计模式

当我们了解完整个数据从请求到对象化的过程之后，数据就成一种 OC 对象可以让开发者十分方便地进行处理了。

我们都知道 MVC 其实讨论的就是数据的流动方向。而 MVC 容易造成 Controller 的臃肿，所以有像 MVVM 这样的模式来减轻 Controller 的负担。接下来以 MVVM 为模型，讨论其中的 ViewModel 在 iOS 中的实现方式。MVVM 基础理论请自行查找相关知识。

![](http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0012/mvvm.png)

### 从 UIKit 寻找数据层的设计

我们可以从 UIKit 里找到苹果在为 ViewCotroller 配置它的数据时的思路。

* DataSource

UITableView 是我们十分熟悉的一个控件了。使用  TableView 时有 Delegate 和 DataSource 两个重要协议需要我们理解。两种协议都可以认为是一种传值的方法。不同的是，Delegate 是将值从 TableView 传到类，而 DataSource 是从类传到 TableView。

![](http://chanjh.b0.upaiyun.com/iOSHub/iOSHubBlog/0012/%E6%96%B0%E6%96%87%E6%A1%A3%202017-10-10%2020.15.51_1.jpg)

这是一种为 ViewController 瘦身的思路。将 ViewController 的 DataSource 设置为我们的 ViewModel，用它来进行数据的装配。

* UISearchController

老实说，UISearchController 是我以前经常不理解的一个类，因为它的调用有点奇怪，不像 TableVIew 这样让一个 ViewController 拥有一个 View，而是让 VC 又拥有了一个新的 Controller，那要怎么理解？

其实我们可以把像 UISearchController 的控制器，称为 DataController。它是从 VC 里抽离出来的关于数据的逻辑处理，以实现 VC 瘦身。让 VC 拥有 DataController 的实例，通过属性读取获得 DataController 的数据、通过方法让 DataController 进行更新。DC 的生命周期保持与 VC 相同。

DataController 是用 own（拥有）的方式将 VC 和 VM 耦合，DataSource 是用 Protocol（协议）的方式将它们耦合在一起。

* 适应性

在业务开发里，我们可能面对这样的设计需求：一种界面对应多种数据、一种数据对应多种界面。具体来说，在我的独立作品 MoSplash 里，同样是展示图片，数据源可能是首页、可能是精选、可能是收藏，这是一对多；另一个情况发生在我们工作室的项目里，同样的通讯录，在聊天里我们希望直接以『老师』分组展示，而另一个界面希望以『数学组』这样的分组展示。

上面提到的 ViewModel 设计模式是不是一定需要对应于后文提到的某种情况？答案显然不是。DataSource 和 DataController 的设计都可以应用进两个情况里。

那会不会会有优劣之分？我个人认为有。但是并不能简单的根据一对多或者多对一就说应该用什么设计。还应该根据业务的复杂度，选择相应设计。上文的例子只是证明，ViewModel 在瘦身和代码复用上的优势。


## 结语

以上就是 iOS 里，一个数据从网络请求结果到缓存，再到业务内的整个过程。希望对入门的同学使用数据层有一个宏观的了解，也希望为使用 MVVM 模型提供一些思路。



- - - -

更多个人分享，可以瞧瞧我不怎么更新的技术博客：[iOSHub](blog.ioshub.cn)。当然还有非技术的 [ChanTalk](zhuanlan.zhihu.com/chantalk)。