---
date: 2017-08-06 19:41
status: public
title: MoSplash 技术开源：iOS 文件下载器是怎么实现的（二）
tags: MoSplash, 教程, iOS, 技术
---

上一篇《[MoSplash 技术开源：iOS 文件下载器是怎么实现的（一）](http://blog.ioshub.cn/2017/08/06/0007/)》里，我讲解了怎么封装 Downloader 这一层，实现了一个单一任务的下载器。但是在很多 App 里，一个下载器并不能满足需求，因而需要封装一个 DownloadManager 类进行下载管理。下载管理和下载器之间怎么对接，下载管理和任务管理之间又怎么对接，这是这篇文章想要解决的问题。

<!--more-->

# 需求分析

没错，在开始敲代码之前要先对需要封装的类进行思考，分析它需要完成什么样的任务，暴露什么样的接口和属性。FileDownloadManager 的需求如下：

```
* Method：
	* shareManager
	* add
	* stop (all or someone)
	* continue(all or someone)
	* fetch
* Property
	* taskCount:NSUInteger
	* taskArray:NSArray
* Callback
	* downloadFinish
	* downloadError
	* progress
```

# 下载管理与下载器对接

FileDownloadManager 和 Downloader 的功能分类有点像，分别是：操作方法（增加任务、暂停、继续）、Downloader 回调（下载完成、下载进度）、下载管理器 Delegate 回调（下载完成、下载进度），还有获取下载状态。

## 操作方法

这里只分析新建下载任务和暂停某个任务，其他的方法可以在文末的 Demo 中查看。

新建下载任务的方法实现如下：

```
@interface FileDownloadManager () <JHDownloadDelegate>
@property (nonatomic, assign) NSUInteger taskCount;
@property (nonatomic, strong) NSMutableArray <JHDownloader *> *taskArray;
@end

# pragma mark - 新建下载线程
+ (void)addTaskWithRequest:(NSURLRequest *)request withDelegate:(id <FileDownloadManagerDelegate>)target{
    FileDownloadManager *manager = [FileDownloadManager shareManager];
    // 检查队列中是否存在该任务
    __block BOOL isExist = NO;
    __block NSUInteger index;
    [manager.taskArray enumerateObjectsUsingBlock:^(JHDownloader * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if([obj.downloadID isEqualToString:request.URL.absoluteString])
        {
            isExist = YES;
            index = idx;
        }
    }];
    if(isExist)
    {
        [FileDownloadManager continueTaskWithIndex:index];
        return;
    }
    manager.delegate = target;
    // 创建任务
    [manager addTaskWithRequest:request];
}

- (void)addTaskWithRequest:(NSURLRequest *)request
{
    JHDownloader *downloader = [JHDownloader downloadWithRequest:request andDelegate:self];
    [_taskArray addObject:downloader];
}
```

这里使用的 manager 对象是单例对象，在整个生命周期里只会实例化一次。在 `addTaskWithRequest:withDelegate:` 方法里，对任务数据使用 `enumerateObjectsUsingBlock` 方法实现异步的遍历，达到更快的遍历效果。

暂停某个任务的时候，也是对任务数组进行遍历，对对应数组进行操作。

```
+ (void)stopTaskWithDownloaderID:(NSString *)downloaderID{
    FileDownloadManager *manager = [FileDownloadManager shareManager];
    [manager.taskArray enumerateObjectsUsingBlock:^(JHDownloader * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if([obj.downloadID isEqualToString:downloaderID])
        {
            [obj stopDownload];
        }
    }];
}
```

值得注意的是，这里的接口方法暴露的都是实例方法，开发者调用这个 API 的时候，不需要实例化就能使用该方法。

## Downloader 回调和 Manager 回调

在 FileDownloaderManager 的 addTask 接口方法里，我们已经将一个 Downloader 的 delegate 设置成了 Manager 本身，因而可以在该类实现对应的 delegate 回调方法。同时，在 delegate 里实现 Manager 的 delegate，这样就实现了从 Downloader 到 Manager 的回调。代码如下：

```

# pragma mark - DownloaderDelegate
/**
 * 下载完成
 */
- (void)finishDownloadWithResponseData:(NSData *)responseData andDownloader:(JHDownloader *)downloader
{
    // 此时下载任务已经完成
    // 将任务从队列中删除
    [self.taskArray enumerateObjectsUsingBlock:^(JHDownloader * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if([obj.downloadID isEqualToString:downloader.downloadID])
        {
            [_taskArray removeObject:obj];
        }
    }];
    
    // 回调
    if([self.delegate respondsToSelector:@selector(taskFinishDownload:withData:)])
    {
        [self.delegate taskFinishDownload:downloader withData:responseData];
    }
}

/**
 * 下载进程
 */
-(void)downloadingWithProgress:(float)progress andDownloader:(JHDownloader *)downloader
{
    if([self.delegate respondsToSelector:@selector(taskDownloadingWithProgress:andDownloader:)])
    {
        [self.delegate taskDownloadingWithProgress:progress andDownloader:downloader];
    }
}
```

至此就完成了一个 DownloadManager 的封装。开发者在使用下载器的时候，可以使用 DownloadManager 的接口方法添加一个任务，同时，将 Manager 的 delegate 设置到正确的类当中。这样就完成了下载器的统一管理和使用。

# But……

在 MoSplash 里，下载图片的时候可以同时设定要不要裁剪图片，裁剪大小是怎么样的。这样，一个下载任务的产生同时还包含着一个图片操作任务。怎样把图片操作任务和下载任务结合，怎样把操作管理和 UI 和其他层互相调用，这些将在《MoSplash 技术开源：iOS 文件下载器是怎么实现的（三）》中进行分享。